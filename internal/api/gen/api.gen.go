// Package gen provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package gen

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for Layer.
const (
	DB         Layer = "DB"
	DOC        Layer = "DOC"
	FRAMEWORK  Layer = "FRAMEWORK"
	LIB        Layer = "LIB"
	MIDDLEWARE Layer = "MIDDLEWARE"
	OS         Layer = "OS"
	OTHER      Layer = "OTHER"
	RUNTIME    Layer = "RUNTIME"
	TOOLBUILD  Layer = "TOOL_BUILD"
	TOOLDEV    Layer = "TOOL_DEV"
	TOOLTEST   Layer = "TOOL_TEST"
)

// Defines values for ReviewStatus.
const (
	Draft    ReviewStatus = "draft"
	Verified ReviewStatus = "verified"
)

// Defines values for Role.
const (
	ADMIN  Role = "ADMIN"
	EDITOR Role = "EDITOR"
	VIEWER Role = "VIEWER"
)

// Defines values for ScopeStatus.
const (
	INSCOPE      ScopeStatus = "IN_SCOPE"
	OUTSCOPE     ScopeStatus = "OUT_SCOPE"
	REVIEWNEEDED ScopeStatus = "REVIEW_NEEDED"
)

// Defines values for SupplierType.
const (
	INTERNALFORK SupplierType = "INTERNAL_FORK"
	REPACKAGE    SupplierType = "REPACKAGE"
	UPSTREAM     SupplierType = "UPSTREAM"
)

// Defines values for UsageRole.
const (
	BUILDONLY       UsageRole = "BUILD_ONLY"
	BUNDLEDBINARY   UsageRole = "BUNDLED_BINARY"
	BUNDLEDSOURCE   UsageRole = "BUNDLED_SOURCE"
	DEVONLY         UsageRole = "DEV_ONLY"
	DYNAMICLINK     UsageRole = "DYNAMIC_LINK"
	RUNTIMEREQUIRED UsageRole = "RUNTIME_REQUIRED"
	SERVERENV       UsageRole = "SERVER_ENV"
	STATICLINK      UsageRole = "STATIC_LINK"
	TESTONLY        UsageRole = "TEST_ONLY"
)

// Defines values for ExportProjectArtifactsParamsFormat.
const (
	Csv      ExportProjectArtifactsParamsFormat = "csv"
	SpdxJson ExportProjectArtifactsParamsFormat = "spdx-json"
)

// Layer OSS 技術レイヤ分類（OS=OS, LIB=ライブラリ 等）
type Layer string

// LoginResponse ログイン成功時のレスポンス
type LoginResponse struct {
	// AccessToken JWT アクセストークン。Authorization: Bearer にセットする
	AccessToken string `json:"accessToken"`

	// ExpiresIn トークンの有効期限（秒）
	ExpiresIn int `json:"expiresIn"`
}

// OssComponent OSS の論理的名称（バージョン共通情報）
type OssComponent struct {
	// CreatedAt 作成日時
	CreatedAt time.Time `json:"createdAt"`

	// DefaultUsageRole プロジェクト内での利用形態（配布対象か／工程限定か）
	DefaultUsageRole *UsageRole `json:"defaultUsageRole,omitempty"`

	// Deprecated 非推奨フラグ（新規利用抑止）
	Deprecated bool `json:"deprecated"`

	// Description 簡易説明 / メモ
	Description *string `json:"description"`

	// HomepageUrl 公式サイト URL
	HomepageUrl *string `json:"homepageUrl"`

	// Id OSSコンポーネント ID
	Id openapi_types.UUID `json:"id"`

	// Layers 技術レイヤ分類（複数指定可）
	Layers *[]Layer `json:"layers,omitempty"`

	// Name 表示名 / ユニーク（大文字小文字区別ポリシーは実装で決定）
	Name string `json:"name"`

	// NormalizedName 検索用正規化名称（小文字化・記号除去）
	NormalizedName *string `json:"normalizedName,omitempty"`

	// PrimaryLanguage 主言語（例: C, C++, Go, Java）
	PrimaryLanguage *string `json:"primaryLanguage"`

	// RepositoryUrl ソースリポジトリ（Git 等）URL
	RepositoryUrl *string `json:"repositoryUrl"`

	// Tags 付与タグ一覧
	Tags *[]Tag `json:"tags,omitempty"`

	// UpdatedAt 更新日時
	UpdatedAt time.Time `json:"updatedAt"`
}

// OssComponentCreateRequest OSSコンポーネント作成リクエスト
type OssComponentCreateRequest struct {
	// DefaultUsageRole プロジェクト内での利用形態（配布対象か／工程限定か）
	DefaultUsageRole *UsageRole `json:"defaultUsageRole,omitempty"`

	// Description 説明 / 備考
	Description *string `json:"description"`

	// HomepageUrl 公式サイト URL
	HomepageUrl *string `json:"homepageUrl"`

	// Layers 技術レイヤ配列
	Layers *[]Layer `json:"layers,omitempty"`

	// Name OSS 表示名
	Name string `json:"name"`

	// PrimaryLanguage 主言語
	PrimaryLanguage *string `json:"primaryLanguage"`

	// RepositoryUrl リポジトリ URL
	RepositoryUrl *string `json:"repositoryUrl"`

	// TagIds 初期付与するタグ ID 群
	TagIds *[]openapi_types.UUID `json:"tagIds,omitempty"`
}

// OssComponentUpdateRequest OSSコンポーネント更新リクエスト（部分）
type OssComponentUpdateRequest struct {
	// DefaultUsageRole プロジェクト内での利用形態（配布対象か／工程限定か）
	DefaultUsageRole *UsageRole `json:"defaultUsageRole,omitempty"`

	// Deprecated 非推奨フラグ
	Deprecated *bool `json:"deprecated,omitempty"`

	// Description 説明 / 備考
	Description *string `json:"description"`

	// HomepageUrl 公式サイト URL
	HomepageUrl *string `json:"homepageUrl"`

	// Layers 技術レイヤ配列
	Layers *[]Layer `json:"layers,omitempty"`

	// Name 新しい名称
	Name *string `json:"name,omitempty"`

	// PrimaryLanguage 主言語
	PrimaryLanguage *string `json:"primaryLanguage"`

	// RepositoryUrl リポジトリ URL
	RepositoryUrl *string `json:"repositoryUrl"`

	// TagIds 置換後のタグ ID 配列
	TagIds *[]openapi_types.UUID `json:"tagIds,omitempty"`
}

// OssVersion 個別バージョン情報
type OssVersion struct {
	// CpeList CPE 文字列配列（脆弱性紐付け用）
	CpeList *[]string `json:"cpeList,omitempty"`

	// CreatedAt 作成日時
	CreatedAt time.Time `json:"createdAt"`

	// ForkOriginUrl フォーク元 URL (INTERNAL_FORK の場合)
	ForkOriginUrl *string `json:"forkOriginUrl"`

	// HashSha256 配布アーカイブ等の SHA-256 ハッシュ
	HashSha256 *string `json:"hashSha256"`

	// Id バージョン ID
	Id openapi_types.UUID `json:"id"`

	// LastReviewedAt 最終レビュー日時
	LastReviewedAt *time.Time `json:"lastReviewedAt"`

	// LicenseConcluded 社内審査確定ライセンス式
	LicenseConcluded *string `json:"licenseConcluded"`

	// LicenseExpressionRaw SPDX 互換ライセンス式（上流取得時点）
	LicenseExpressionRaw *string `json:"licenseExpressionRaw"`

	// ModificationDescription 改変内容概要
	ModificationDescription *string `json:"modificationDescription"`

	// Modified 社内改変有無
	Modified bool `json:"modified"`

	// OssId 親 OSSコンポーネント ID
	OssId openapi_types.UUID `json:"ossId"`

	// Purl package-url (例: pkg:maven/...)
	Purl *string `json:"purl"`

	// ReleaseDate 上流リリース日
	ReleaseDate *openapi_types.Date `json:"releaseDate"`

	// ReviewStatus バージョンレビュー状態（draft=未承認, verified=確認済）
	ReviewStatus ReviewStatus `json:"reviewStatus"`

	// ScopeStatus 納品対象スコープ判定状態（IN_SCOPE=含む, OUT_SCOPE=除外, REVIEW_NEEDED=要判定）
	ScopeStatus ScopeStatus `json:"scopeStatus"`

	// SupplierType 取得・供給形態（フォークや再パッケージか）
	SupplierType *SupplierType `json:"supplierType,omitempty"`

	// UpdatedAt 更新日時
	UpdatedAt time.Time `json:"updatedAt"`

	// Version バージョン文字列 (SemVer 互換推奨)
	Version string `json:"version"`
}

// OssVersionCreateRequest バージョン作成リクエスト
type OssVersionCreateRequest struct {
	// CpeList CPE 配列
	CpeList *[]string `json:"cpeList,omitempty"`

	// ForkOriginUrl フォーク元 URL
	ForkOriginUrl *string `json:"forkOriginUrl"`

	// HashSha256 アーカイブ SHA-256
	HashSha256 *string `json:"hashSha256"`

	// LicenseExpressionRaw 生ライセンス式
	LicenseExpressionRaw *string `json:"licenseExpressionRaw"`

	// ModificationDescription 改変概要
	ModificationDescription *string `json:"modificationDescription"`

	// Modified 社内改変有無
	Modified *bool `json:"modified,omitempty"`

	// Purl package-url
	Purl *string `json:"purl"`

	// ReleaseDate リリース日
	ReleaseDate *openapi_types.Date `json:"releaseDate"`

	// SupplierType 取得・供給形態（フォークや再パッケージか）
	SupplierType *SupplierType `json:"supplierType,omitempty"`

	// Version バージョン文字列
	Version string `json:"version"`
}

// OssVersionUpdateRequest バージョン更新リクエスト（部分）
type OssVersionUpdateRequest struct {
	// CpeList CPE 配列
	CpeList *[]string `json:"cpeList,omitempty"`

	// ForkOriginUrl フォーク元 URL
	ForkOriginUrl *string `json:"forkOriginUrl"`

	// HashSha256 SHA-256 ハッシュ
	HashSha256 *string `json:"hashSha256"`

	// LicenseConcluded 確定ライセンス式
	LicenseConcluded *string `json:"licenseConcluded"`

	// LicenseExpressionRaw 生ライセンス式
	LicenseExpressionRaw *string `json:"licenseExpressionRaw"`

	// ModificationDescription 改変概要
	ModificationDescription *string `json:"modificationDescription"`

	// Modified 改変有無
	Modified *bool `json:"modified,omitempty"`

	// Purl package-url
	Purl *string `json:"purl"`

	// ReleaseDate リリース日
	ReleaseDate *openapi_types.Date `json:"releaseDate"`

	// ReviewStatus バージョンレビュー状態（draft=未承認, verified=確認済）
	ReviewStatus *ReviewStatus `json:"reviewStatus,omitempty"`

	// ScopeStatus 納品対象スコープ判定状態（IN_SCOPE=含む, OUT_SCOPE=除外, REVIEW_NEEDED=要判定）
	ScopeStatus *ScopeStatus `json:"scopeStatus,omitempty"`

	// SupplierType 取得・供給形態（フォークや再パッケージか）
	SupplierType *SupplierType `json:"supplierType,omitempty"`
}

// PagedResultOssComponent OSSコンポーネントページング結果
type PagedResultOssComponent struct {
	// Items 結果アイテム配列
	Items *[]OssComponent `json:"items,omitempty"`

	// Page 現在ページ (1 始まり)
	Page *int `json:"page,omitempty"`

	// Size ページサイズ
	Size *int `json:"size,omitempty"`

	// Total 総件数
	Total *int `json:"total,omitempty"`
}

// PagedResultOssVersion OSS バージョンページング結果
type PagedResultOssVersion struct {
	// Items 結果アイテム配列
	Items *[]OssVersion `json:"items,omitempty"`

	// Page 現在ページ
	Page *int `json:"page,omitempty"`

	// Size ページサイズ
	Size *int `json:"size,omitempty"`

	// Total 総件数
	Total *int `json:"total,omitempty"`
}

// PagedResultProject プロジェクト一覧ページング結果
type PagedResultProject struct {
	// Items 結果アイテム配列
	Items *[]Project `json:"items,omitempty"`

	// Page 現在ページ
	Page *int `json:"page,omitempty"`

	// Size ページサイズ
	Size *int `json:"size,omitempty"`

	// Total 総件数
	Total *int `json:"total,omitempty"`
}

// PagedResultProjectUsage プロジェクト利用レコードのページング結果
type PagedResultProjectUsage struct {
	// Items 結果アイテム配列
	Items *[]ProjectUsage `json:"items,omitempty"`

	// Page 現在ページ
	Page *int `json:"page,omitempty"`

	// Size ページサイズ
	Size *int `json:"size,omitempty"`

	// Total 総件数
	Total *int `json:"total,omitempty"`
}

// PagedResultUser ユーザー一覧ページング結果
type PagedResultUser struct {
	Items *[]User `json:"items,omitempty"`
	Page  *int    `json:"page,omitempty"`
	Size  *int    `json:"size,omitempty"`
	Total *int    `json:"total,omitempty"`
}

// Problem RFC 9457 / RFC 7807 型エラー応答ボディ
type Problem struct {
	// Code アプリケーション独自エラーコード
	Code *string `json:"code"`

	// Detail 追加詳細メッセージ
	Detail *string `json:"detail"`

	// Errors フィールド単位バリデーションエラー配列
	Errors *[]struct {
		// Field エラーが発生したフィールド名（JSON Pointer など）
		Field *string `json:"field,omitempty"`

		// Message フィールドに対するエラーメッセージ
		Message *string `json:"message,omitempty"`
	} `json:"errors,omitempty"`

	// Instance エラーが発生した具体的インスタンス URI（トレースID等）
	Instance *string `json:"instance"`

	// Status HTTP ステータスコード
	Status int `json:"status"`

	// Title エラーの概要メッセージ（人間可読）
	Title string `json:"title"`

	// Type 問題タイプ識別 URI（拡張分類用）
	Type *string `json:"type"`
}

// Project プロジェクト（納品単位）
type Project struct {
	// CreatedAt 作成日時
	CreatedAt time.Time `json:"createdAt"`

	// DeliveryDate 納品予定日
	DeliveryDate *openapi_types.Date `json:"deliveryDate"`

	// Department 担当部署
	Department *string `json:"department"`

	// Description 説明 / 備考
	Description *string `json:"description"`

	// Id プロジェクト ID
	Id openapi_types.UUID `json:"id"`

	// Manager 責任者 / 担当者名
	Manager *string `json:"manager"`

	// Name プロジェクト名称
	Name string `json:"name"`

	// OssUsageCount 紐付く OSS 利用件数集計
	OssUsageCount *int `json:"ossUsageCount,omitempty"`

	// ProjectCode 社内識別コード（ユニーク）
	ProjectCode string `json:"projectCode"`

	// UpdatedAt 更新日時
	UpdatedAt time.Time `json:"updatedAt"`
}

// ProjectCreateRequest プロジェクト作成リクエスト
type ProjectCreateRequest struct {
	// DeliveryDate 納品日
	DeliveryDate *openapi_types.Date `json:"deliveryDate"`

	// Department 部署
	Department *string `json:"department"`

	// Description 説明 / 備考
	Description *string `json:"description"`

	// Manager 責任者
	Manager *string `json:"manager"`

	// Name 名称
	Name string `json:"name"`

	// ProjectCode ユニークなプロジェクトコード
	ProjectCode string `json:"projectCode"`
}

// ProjectUpdateRequest プロジェクト更新リクエスト
type ProjectUpdateRequest struct {
	// DeliveryDate 納品日
	DeliveryDate *openapi_types.Date `json:"deliveryDate"`

	// Department 部署
	Department *string `json:"department"`

	// Description 説明 / 備考
	Description *string `json:"description"`

	// Manager 責任者
	Manager *string `json:"manager"`

	// Name 名称
	Name *string `json:"name,omitempty"`
}

// ProjectUsage プロジェクトにおける特定 OSS バージョンの利用レコード
type ProjectUsage struct {
	// AddedAt 登録日時
	AddedAt time.Time `json:"addedAt"`

	// DirectDependency 直接依存なら true (間接は false)
	DirectDependency bool `json:"directDependency"`

	// EvaluatedAt スコープ判定更新日時
	EvaluatedAt *time.Time `json:"evaluatedAt"`

	// EvaluatedBy 判定実施ユーザ
	EvaluatedBy *string `json:"evaluatedBy"`

	// Id 利用 ID
	Id openapi_types.UUID `json:"id"`

	// InclusionNote IN/OUT 判断理由メモ
	InclusionNote *string `json:"inclusionNote"`

	// OssId OSSコンポーネント ID (利便性重複)
	OssId openapi_types.UUID `json:"ossId"`

	// OssVersionId OSS バージョン ID
	OssVersionId openapi_types.UUID `json:"ossVersionId"`

	// ProjectId プロジェクト ID
	ProjectId openapi_types.UUID `json:"projectId"`

	// ScopeStatus 納品対象スコープ判定状態（IN_SCOPE=含む, OUT_SCOPE=除外, REVIEW_NEEDED=要判定）
	ScopeStatus ScopeStatus `json:"scopeStatus"`

	// UsageRole プロジェクト内での利用形態（配布対象か／工程限定か）
	UsageRole UsageRole `json:"usageRole"`
}

// ProjectUsageCreateRequest プロジェクト利用作成リクエスト
type ProjectUsageCreateRequest struct {
	// DirectDependency 直接依存なら true
	DirectDependency *bool `json:"directDependency,omitempty"`

	// InclusionNote 初期理由メモ
	InclusionNote *string `json:"inclusionNote"`

	// OssId OSSコンポーネント ID
	OssId openapi_types.UUID `json:"ossId"`

	// OssVersionId OSS バージョン ID
	OssVersionId openapi_types.UUID `json:"ossVersionId"`

	// UsageRole プロジェクト内での利用形態（配布対象か／工程限定か）
	UsageRole UsageRole `json:"usageRole"`
}

// ProjectUsageUpdateRequest プロジェクト利用更新リクエスト
type ProjectUsageUpdateRequest struct {
	// DirectDependency 直接依存フラグ
	DirectDependency *bool `json:"directDependency,omitempty"`

	// InclusionNote 理由メモ
	InclusionNote *string `json:"inclusionNote"`

	// OssVersionId 新しい OSS バージョン ID
	OssVersionId *openapi_types.UUID `json:"ossVersionId,omitempty"`

	// ScopeStatus 納品対象スコープ判定状態（IN_SCOPE=含む, OUT_SCOPE=除外, REVIEW_NEEDED=要判定）
	ScopeStatus *ScopeStatus `json:"scopeStatus,omitempty"`

	// UsageRole プロジェクト内での利用形態（配布対象か／工程限定か）
	UsageRole *UsageRole `json:"usageRole,omitempty"`
}

// ReviewStatus バージョンレビュー状態（draft=未承認, verified=確認済）
type ReviewStatus string

// Role アクセス制御ロール（ADMIN=全権, EDITOR=編集可, VIEWER=参照のみ）
type Role string

// ScopePolicy スコープ自動判定ポリシー設定
type ScopePolicy struct {
	// AutoMarkForksInScope INTERNAL_FORK を自動 IN_SCOPE 化するか
	AutoMarkForksInScope *bool `json:"autoMarkForksInScope,omitempty"`

	// Id ポリシー ID
	Id *openapi_types.UUID `json:"id,omitempty"`

	// RuntimeRequiredDefaultInScope RUNTIME_REQUIRED を自動 IN_SCOPE にするフラグ
	RuntimeRequiredDefaultInScope *bool `json:"runtimeRequiredDefaultInScope,omitempty"`

	// ServerEnvIncluded SERVER_ENV を IN_SCOPE とみなすか
	ServerEnvIncluded *bool `json:"serverEnvIncluded,omitempty"`

	// UpdatedAt 最終更新日時
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// UpdatedBy 更新ユーザ
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// ScopePolicyUpdateRequest スコープポリシー更新リクエスト
type ScopePolicyUpdateRequest struct {
	// AutoMarkForksInScope INTERNAL_FORK 自動 IN_SCOPE フラグ
	AutoMarkForksInScope *bool `json:"autoMarkForksInScope,omitempty"`

	// RuntimeRequiredDefaultInScope RUNTIME_REQUIRED 自動 IN_SCOPE フラグ
	RuntimeRequiredDefaultInScope *bool `json:"runtimeRequiredDefaultInScope,omitempty"`

	// ServerEnvIncluded SERVER_ENV を IN_SCOPE とするか
	ServerEnvIncluded *bool `json:"serverEnvIncluded,omitempty"`
}

// ScopeStatus 納品対象スコープ判定状態（IN_SCOPE=含む, OUT_SCOPE=除外, REVIEW_NEEDED=要判定）
type ScopeStatus string

// ScopeStatusUpdateRequest スコープ判定更新リクエスト
type ScopeStatusUpdateRequest struct {
	// ReasonCode 理由コード (マスタ化想定)
	ReasonCode *string `json:"reasonCode"`

	// ReasonNote 自由記述理由
	ReasonNote *string `json:"reasonNote"`

	// ScopeStatus 納品対象スコープ判定状態（IN_SCOPE=含む, OUT_SCOPE=除外, REVIEW_NEEDED=要判定）
	ScopeStatus ScopeStatus `json:"scopeStatus"`
}

// SupplierType 取得・供給形態（フォークや再パッケージか）
type SupplierType string

// Tag OSSコンポーネントに付与する分類タグ
type Tag struct {
	// CreatedAt 作成日時
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Id タグ ID
	Id openapi_types.UUID `json:"id"`

	// Name タグ名称（ユニーク）
	Name string `json:"name"`
}

// TagCreateRequest タグ作成リクエスト
type TagCreateRequest struct {
	// Name タグ名称
	Name string `json:"name"`
}

// UsageRole プロジェクト内での利用形態（配布対象か／工程限定か）
type UsageRole string

// User システム利用ユーザー情報
type User struct {
	// Active 有効/無効フラグ
	Active bool `json:"active"`

	// CreatedAt 作成日時
	CreatedAt time.Time `json:"createdAt"`

	// DisplayName 表示名
	DisplayName *string `json:"displayName,omitempty"`

	// Email メールアドレス
	Email *openapi_types.Email `json:"email"`

	// Id ユーザーID
	Id openapi_types.UUID `json:"id"`

	// Roles 付与ロール一覧
	Roles []Role `json:"roles"`

	// UpdatedAt 更新日時
	UpdatedAt time.Time `json:"updatedAt"`

	// Username ログインID（ユニーク）
	Username string `json:"username"`
}

// UserCreateRequest ユーザー作成リクエスト
type UserCreateRequest struct {
	// Active 有効化フラグ
	Active *bool `json:"active,omitempty"`

	// DisplayName 表示名
	DisplayName *string `json:"displayName,omitempty"`

	// Email メールアドレス
	Email *openapi_types.Email `json:"email"`

	// Password 初期パスワード（JWTでも登録時のみ使用可）
	Password *string `json:"password,omitempty"`

	// Roles 付与するロール一覧
	Roles []Role `json:"roles"`

	// Username ログインID
	Username string `json:"username"`
}

// UserUpdateRequest ユーザー更新リクエスト（部分）
type UserUpdateRequest struct {
	// Active 有効/無効切替
	Active *bool `json:"active,omitempty"`

	// DisplayName 表示名
	DisplayName *string `json:"displayName,omitempty"`

	// Email メールアドレス
	Email *openapi_types.Email `json:"email"`

	// Password パスワード再設定用（任意）
	Password *string `json:"password,omitempty"`

	// Roles 付与ロール一覧（管理者のみ変更可）
	Roles *[]Role `json:"roles,omitempty"`
}

// PageParam defines model for PageParam.
type PageParam = int

// SizeParam defines model for SizeParam.
type SizeParam = int

// SortParam defines model for SortParam.
type SortParam = string

// BadRequest RFC 9457 / RFC 7807 型エラー応答ボディ
type BadRequest = Problem

// Forbidden RFC 9457 / RFC 7807 型エラー応答ボディ
type Forbidden = Problem

// NotFound RFC 9457 / RFC 7807 型エラー応答ボディ
type NotFound = Problem

// Unauthorized RFC 9457 / RFC 7807 型エラー応答ボディ
type Unauthorized = Problem

// SearchAuditLogsParams defines parameters for SearchAuditLogs.
type SearchAuditLogsParams struct {
	EntityType *string    `form:"entityType,omitempty" json:"entityType,omitempty"`
	EntityId   *string    `form:"entityId,omitempty" json:"entityId,omitempty"`
	From       *time.Time `form:"from,omitempty" json:"from,omitempty"`
	To         *time.Time `form:"to,omitempty" json:"to,omitempty"`
}

// LoginJSONBody defines parameters for Login.
type LoginJSONBody struct {
	// Password パスワード
	Password string `json:"password"`

	// Username ログインID
	Username string `json:"username"`
}

// ListOssComponentsParams defines parameters for ListOssComponents.
type ListOssComponentsParams struct {
	// Page 1 始まりのページ番号
	Page *PageParam `form:"page,omitempty" json:"page,omitempty"`

	// Size 1ページ件数 (最大 200)
	Size *SizeParam `form:"size,omitempty" json:"size,omitempty"`

	// Sort ソート指定 (例: name,asc / createdAt,desc)
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Name 部分一致
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Layers カンマ区切り Layer フィルタ (例 LIB,DB)
	Layers *string `form:"layers,omitempty" json:"layers,omitempty"`

	// Tag タグ名 (正確一致)
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// InScopeOnly true の場合 IN_SCOPE のバージョンを一つ以上持つもののみ
	InScopeOnly *bool `form:"inScopeOnly,omitempty" json:"inScopeOnly,omitempty"`
}

// ListOssVersionsParams defines parameters for ListOssVersions.
type ListOssVersionsParams struct {
	// Page 1 始まりのページ番号
	Page *PageParam `form:"page,omitempty" json:"page,omitempty"`

	// Size 1ページ件数 (最大 200)
	Size         *SizeParam    `form:"size,omitempty" json:"size,omitempty"`
	ReviewStatus *ReviewStatus `form:"reviewStatus,omitempty" json:"reviewStatus,omitempty"`
	ScopeStatus  *ScopeStatus  `form:"scopeStatus,omitempty" json:"scopeStatus,omitempty"`
}

// ListProjectsParams defines parameters for ListProjects.
type ListProjectsParams struct {
	// Page 1 始まりのページ番号
	Page *PageParam `form:"page,omitempty" json:"page,omitempty"`

	// Size 1ページ件数 (最大 200)
	Size *SizeParam `form:"size,omitempty" json:"size,omitempty"`
	Code *string    `form:"code,omitempty" json:"code,omitempty"`
	Name *string    `form:"name,omitempty" json:"name,omitempty"`
}

// ExportProjectArtifactsParams defines parameters for ExportProjectArtifacts.
type ExportProjectArtifactsParams struct {
	Format ExportProjectArtifactsParamsFormat `form:"format" json:"format"`
	Scopes *string                            `form:"scopes,omitempty" json:"scopes,omitempty"`
}

// ExportProjectArtifactsParamsFormat defines parameters for ExportProjectArtifacts.
type ExportProjectArtifactsParamsFormat string

// ListProjectUsagesParams defines parameters for ListProjectUsages.
type ListProjectUsagesParams struct {
	// Page 1 始まりのページ番号
	Page *PageParam `form:"page,omitempty" json:"page,omitempty"`

	// Size 1ページ件数 (最大 200)
	Size        *SizeParam   `form:"size,omitempty" json:"size,omitempty"`
	ScopeStatus *ScopeStatus `form:"scopeStatus,omitempty" json:"scopeStatus,omitempty"`
	UsageRole   *UsageRole   `form:"usageRole,omitempty" json:"usageRole,omitempty"`

	// Direct 直接依存のみ true
	Direct *bool `form:"direct,omitempty" json:"direct,omitempty"`
}

// ListUsersParams defines parameters for ListUsers.
type ListUsersParams struct {
	// Page 1 始まりのページ番号
	Page *PageParam `form:"page,omitempty" json:"page,omitempty"`

	// Size 1ページ件数 (最大 200)
	Size *SizeParam `form:"size,omitempty" json:"size,omitempty"`

	// Username 部分一致検索
	Username *string `form:"username,omitempty" json:"username,omitempty"`

	// Role ロールで絞り込み
	Role *Role `form:"role,omitempty" json:"role,omitempty"`
}

// LoginJSONRequestBody defines body for Login for application/json ContentType.
type LoginJSONRequestBody LoginJSONBody

// CreateOssComponentJSONRequestBody defines body for CreateOssComponent for application/json ContentType.
type CreateOssComponentJSONRequestBody = OssComponentCreateRequest

// UpdateOssComponentJSONRequestBody defines body for UpdateOssComponent for application/json ContentType.
type UpdateOssComponentJSONRequestBody = OssComponentUpdateRequest

// CreateOssVersionJSONRequestBody defines body for CreateOssVersion for application/json ContentType.
type CreateOssVersionJSONRequestBody = OssVersionCreateRequest

// UpdateOssVersionJSONRequestBody defines body for UpdateOssVersion for application/json ContentType.
type UpdateOssVersionJSONRequestBody = OssVersionUpdateRequest

// CreateProjectJSONRequestBody defines body for CreateProject for application/json ContentType.
type CreateProjectJSONRequestBody = ProjectCreateRequest

// UpdateProjectJSONRequestBody defines body for UpdateProject for application/json ContentType.
type UpdateProjectJSONRequestBody = ProjectUpdateRequest

// CreateProjectUsageJSONRequestBody defines body for CreateProjectUsage for application/json ContentType.
type CreateProjectUsageJSONRequestBody = ProjectUsageCreateRequest

// UpdateProjectUsageJSONRequestBody defines body for UpdateProjectUsage for application/json ContentType.
type UpdateProjectUsageJSONRequestBody = ProjectUsageUpdateRequest

// UpdateProjectUsageScopeJSONRequestBody defines body for UpdateProjectUsageScope for application/json ContentType.
type UpdateProjectUsageScopeJSONRequestBody = ScopeStatusUpdateRequest

// UpdateScopePolicyJSONRequestBody defines body for UpdateScopePolicy for application/json ContentType.
type UpdateScopePolicyJSONRequestBody = ScopePolicyUpdateRequest

// CreateTagJSONRequestBody defines body for CreateTag for application/json ContentType.
type CreateTagJSONRequestBody = TagCreateRequest

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody = UserCreateRequest

// UpdateUserJSONRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody = UserUpdateRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// 監査ログ簡易検索 (Phase1簡易)
	// (GET /audit)
	SearchAuditLogs(ctx echo.Context, params SearchAuditLogsParams) error
	// ログイン（JWT発行）
	// (POST /auth/login)
	Login(ctx echo.Context) error
	// ログアウト（アクセストークン無効化／ログ記録用）
	// (POST /auth/logout)
	Logout(ctx echo.Context) error
	// 現在ログイン中ユーザー情報取得
	// (GET /me)
	GetCurrentUser(ctx echo.Context) error
	// OSSコンポーネント一覧取得
	// (GET /oss)
	ListOssComponents(ctx echo.Context, params ListOssComponentsParams) error
	// OSSコンポーネント作成
	// (POST /oss)
	CreateOssComponent(ctx echo.Context) error
	// OSSコンポーネントを非推奨 (deprecated=true) に設定
	// (DELETE /oss/{ossId})
	DeprecateOssComponent(ctx echo.Context, ossId openapi_types.UUID) error
	// OSSコンポーネント詳細
	// (GET /oss/{ossId})
	GetOssComponent(ctx echo.Context, ossId openapi_types.UUID) error
	// OSSコンポーネント更新 (部分)
	// (PATCH /oss/{ossId})
	UpdateOssComponent(ctx echo.Context, ossId openapi_types.UUID) error
	// 指定 OSS のバージョン一覧
	// (GET /oss/{ossId}/versions)
	ListOssVersions(ctx echo.Context, ossId openapi_types.UUID, params ListOssVersionsParams) error
	// バージョン追加
	// (POST /oss/{ossId}/versions)
	CreateOssVersion(ctx echo.Context, ossId openapi_types.UUID) error
	// バージョン削除 (論理/物理は実装方針による)
	// (DELETE /oss/{ossId}/versions/{versionId})
	DeleteOssVersion(ctx echo.Context, ossId openapi_types.UUID, versionId openapi_types.UUID) error
	// バージョン詳細
	// (GET /oss/{ossId}/versions/{versionId})
	GetOssVersion(ctx echo.Context, ossId openapi_types.UUID, versionId openapi_types.UUID) error
	// バージョン更新
	// (PATCH /oss/{ossId}/versions/{versionId})
	UpdateOssVersion(ctx echo.Context, ossId openapi_types.UUID, versionId openapi_types.UUID) error
	// プロジェクト一覧
	// (GET /projects)
	ListProjects(ctx echo.Context, params ListProjectsParams) error
	// プロジェクト作成
	// (POST /projects)
	CreateProject(ctx echo.Context) error
	// プロジェクト削除 (論理予定)
	// (DELETE /projects/{projectId})
	DeleteProject(ctx echo.Context, projectId openapi_types.UUID) error
	// プロジェクト詳細
	// (GET /projects/{projectId})
	GetProject(ctx echo.Context, projectId openapi_types.UUID) error
	// プロジェクト更新
	// (PATCH /projects/{projectId})
	UpdateProject(ctx echo.Context, projectId openapi_types.UUID) error
	// プロジェクト納品用エクスポート (プレースホルダ)
	// (GET /projects/{projectId}/export)
	ExportProjectArtifacts(ctx echo.Context, projectId openapi_types.UUID, params ExportProjectArtifactsParams) error
	// プロジェクト中利用 OSS 一覧
	// (GET /projects/{projectId}/usages)
	ListProjectUsages(ctx echo.Context, projectId openapi_types.UUID, params ListProjectUsagesParams) error
	// プロジェクト利用追加
	// (POST /projects/{projectId}/usages)
	CreateProjectUsage(ctx echo.Context, projectId openapi_types.UUID) error
	// 利用削除
	// (DELETE /projects/{projectId}/usages/{usageId})
	DeleteProjectUsage(ctx echo.Context, projectId openapi_types.UUID, usageId openapi_types.UUID) error
	// 利用情報更新
	// (PATCH /projects/{projectId}/usages/{usageId})
	UpdateProjectUsage(ctx echo.Context, projectId openapi_types.UUID, usageId openapi_types.UUID) error
	// スコープ判定更新
	// (PATCH /projects/{projectId}/usages/{usageId}/scope)
	UpdateProjectUsageScope(ctx echo.Context, projectId openapi_types.UUID, usageId openapi_types.UUID) error
	// 現行スコープポリシー取得
	// (GET /scope/policy)
	GetScopePolicy(ctx echo.Context) error
	// スコープポリシー更新 (管理者)
	// (PATCH /scope/policy)
	UpdateScopePolicy(ctx echo.Context) error
	// タグ一覧
	// (GET /tags)
	ListTags(ctx echo.Context) error
	// タグ作成
	// (POST /tags)
	CreateTag(ctx echo.Context) error
	// タグ削除
	// (DELETE /tags/{tagId})
	DeleteTag(ctx echo.Context, tagId openapi_types.UUID) error
	// ユーザー一覧
	// (GET /users)
	ListUsers(ctx echo.Context, params ListUsersParams) error
	// ユーザー作成
	// (POST /users)
	CreateUser(ctx echo.Context) error
	// ユーザー削除 (論理/物理は実装次第)
	// (DELETE /users/{userId})
	DeleteUser(ctx echo.Context, userId openapi_types.UUID) error
	// ユーザー詳細
	// (GET /users/{userId})
	GetUser(ctx echo.Context, userId openapi_types.UUID) error
	// ユーザー更新
	// (PATCH /users/{userId})
	UpdateUser(ctx echo.Context, userId openapi_types.UUID) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchAuditLogs converts echo context to params.
func (w *ServerInterfaceWrapper) SearchAuditLogs(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchAuditLogsParams
	// ------------- Optional query parameter "entityType" -------------

	err = runtime.BindQueryParameter("form", true, false, "entityType", ctx.QueryParams(), &params.EntityType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter entityType: %s", err))
	}

	// ------------- Optional query parameter "entityId" -------------

	err = runtime.BindQueryParameter("form", true, false, "entityId", ctx.QueryParams(), &params.EntityId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter entityId: %s", err))
	}

	// ------------- Optional query parameter "from" -------------

	err = runtime.BindQueryParameter("form", true, false, "from", ctx.QueryParams(), &params.From)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter from: %s", err))
	}

	// ------------- Optional query parameter "to" -------------

	err = runtime.BindQueryParameter("form", true, false, "to", ctx.QueryParams(), &params.To)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter to: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SearchAuditLogs(ctx, params)
	return err
}

// Login converts echo context to params.
func (w *ServerInterfaceWrapper) Login(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Login(ctx)
	return err
}

// Logout converts echo context to params.
func (w *ServerInterfaceWrapper) Logout(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Logout(ctx)
	return err
}

// GetCurrentUser converts echo context to params.
func (w *ServerInterfaceWrapper) GetCurrentUser(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCurrentUser(ctx)
	return err
}

// ListOssComponents converts echo context to params.
func (w *ServerInterfaceWrapper) ListOssComponents(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListOssComponentsParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", ctx.QueryParams(), &params.Size)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter size: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "layers" -------------

	err = runtime.BindQueryParameter("form", true, false, "layers", ctx.QueryParams(), &params.Layers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter layers: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "inScopeOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "inScopeOnly", ctx.QueryParams(), &params.InScopeOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter inScopeOnly: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListOssComponents(ctx, params)
	return err
}

// CreateOssComponent converts echo context to params.
func (w *ServerInterfaceWrapper) CreateOssComponent(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateOssComponent(ctx)
	return err
}

// DeprecateOssComponent converts echo context to params.
func (w *ServerInterfaceWrapper) DeprecateOssComponent(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ossId" -------------
	var ossId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "ossId", ctx.Param("ossId"), &ossId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ossId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeprecateOssComponent(ctx, ossId)
	return err
}

// GetOssComponent converts echo context to params.
func (w *ServerInterfaceWrapper) GetOssComponent(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ossId" -------------
	var ossId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "ossId", ctx.Param("ossId"), &ossId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ossId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetOssComponent(ctx, ossId)
	return err
}

// UpdateOssComponent converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateOssComponent(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ossId" -------------
	var ossId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "ossId", ctx.Param("ossId"), &ossId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ossId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateOssComponent(ctx, ossId)
	return err
}

// ListOssVersions converts echo context to params.
func (w *ServerInterfaceWrapper) ListOssVersions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ossId" -------------
	var ossId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "ossId", ctx.Param("ossId"), &ossId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ossId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListOssVersionsParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", ctx.QueryParams(), &params.Size)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter size: %s", err))
	}

	// ------------- Optional query parameter "reviewStatus" -------------

	err = runtime.BindQueryParameter("form", true, false, "reviewStatus", ctx.QueryParams(), &params.ReviewStatus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter reviewStatus: %s", err))
	}

	// ------------- Optional query parameter "scopeStatus" -------------

	err = runtime.BindQueryParameter("form", true, false, "scopeStatus", ctx.QueryParams(), &params.ScopeStatus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scopeStatus: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListOssVersions(ctx, ossId, params)
	return err
}

// CreateOssVersion converts echo context to params.
func (w *ServerInterfaceWrapper) CreateOssVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ossId" -------------
	var ossId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "ossId", ctx.Param("ossId"), &ossId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ossId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateOssVersion(ctx, ossId)
	return err
}

// DeleteOssVersion converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteOssVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ossId" -------------
	var ossId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "ossId", ctx.Param("ossId"), &ossId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ossId: %s", err))
	}

	// ------------- Path parameter "versionId" -------------
	var versionId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "versionId", ctx.Param("versionId"), &versionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter versionId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteOssVersion(ctx, ossId, versionId)
	return err
}

// GetOssVersion converts echo context to params.
func (w *ServerInterfaceWrapper) GetOssVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ossId" -------------
	var ossId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "ossId", ctx.Param("ossId"), &ossId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ossId: %s", err))
	}

	// ------------- Path parameter "versionId" -------------
	var versionId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "versionId", ctx.Param("versionId"), &versionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter versionId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetOssVersion(ctx, ossId, versionId)
	return err
}

// UpdateOssVersion converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateOssVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ossId" -------------
	var ossId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "ossId", ctx.Param("ossId"), &ossId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ossId: %s", err))
	}

	// ------------- Path parameter "versionId" -------------
	var versionId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "versionId", ctx.Param("versionId"), &versionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter versionId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateOssVersion(ctx, ossId, versionId)
	return err
}

// ListProjects converts echo context to params.
func (w *ServerInterfaceWrapper) ListProjects(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListProjectsParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", ctx.QueryParams(), &params.Size)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter size: %s", err))
	}

	// ------------- Optional query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, false, "code", ctx.QueryParams(), &params.Code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListProjects(ctx, params)
	return err
}

// CreateProject converts echo context to params.
func (w *ServerInterfaceWrapper) CreateProject(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateProject(ctx)
	return err
}

// DeleteProject converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteProject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteProject(ctx, projectId)
	return err
}

// GetProject converts echo context to params.
func (w *ServerInterfaceWrapper) GetProject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetProject(ctx, projectId)
	return err
}

// UpdateProject converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateProject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateProject(ctx, projectId)
	return err
}

// ExportProjectArtifacts converts echo context to params.
func (w *ServerInterfaceWrapper) ExportProjectArtifacts(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ExportProjectArtifactsParams
	// ------------- Required query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, true, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "scopes" -------------

	err = runtime.BindQueryParameter("form", true, false, "scopes", ctx.QueryParams(), &params.Scopes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scopes: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ExportProjectArtifacts(ctx, projectId, params)
	return err
}

// ListProjectUsages converts echo context to params.
func (w *ServerInterfaceWrapper) ListProjectUsages(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListProjectUsagesParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", ctx.QueryParams(), &params.Size)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter size: %s", err))
	}

	// ------------- Optional query parameter "scopeStatus" -------------

	err = runtime.BindQueryParameter("form", true, false, "scopeStatus", ctx.QueryParams(), &params.ScopeStatus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scopeStatus: %s", err))
	}

	// ------------- Optional query parameter "usageRole" -------------

	err = runtime.BindQueryParameter("form", true, false, "usageRole", ctx.QueryParams(), &params.UsageRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter usageRole: %s", err))
	}

	// ------------- Optional query parameter "direct" -------------

	err = runtime.BindQueryParameter("form", true, false, "direct", ctx.QueryParams(), &params.Direct)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direct: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListProjectUsages(ctx, projectId, params)
	return err
}

// CreateProjectUsage converts echo context to params.
func (w *ServerInterfaceWrapper) CreateProjectUsage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateProjectUsage(ctx, projectId)
	return err
}

// DeleteProjectUsage converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteProjectUsage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	// ------------- Path parameter "usageId" -------------
	var usageId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "usageId", ctx.Param("usageId"), &usageId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter usageId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteProjectUsage(ctx, projectId, usageId)
	return err
}

// UpdateProjectUsage converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateProjectUsage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	// ------------- Path parameter "usageId" -------------
	var usageId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "usageId", ctx.Param("usageId"), &usageId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter usageId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateProjectUsage(ctx, projectId, usageId)
	return err
}

// UpdateProjectUsageScope converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateProjectUsageScope(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	// ------------- Path parameter "usageId" -------------
	var usageId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "usageId", ctx.Param("usageId"), &usageId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter usageId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateProjectUsageScope(ctx, projectId, usageId)
	return err
}

// GetScopePolicy converts echo context to params.
func (w *ServerInterfaceWrapper) GetScopePolicy(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScopePolicy(ctx)
	return err
}

// UpdateScopePolicy converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateScopePolicy(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateScopePolicy(ctx)
	return err
}

// ListTags converts echo context to params.
func (w *ServerInterfaceWrapper) ListTags(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListTags(ctx)
	return err
}

// CreateTag converts echo context to params.
func (w *ServerInterfaceWrapper) CreateTag(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateTag(ctx)
	return err
}

// DeleteTag converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteTag(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "tagId" -------------
	var tagId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "tagId", ctx.Param("tagId"), &tagId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tagId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteTag(ctx, tagId)
	return err
}

// ListUsers converts echo context to params.
func (w *ServerInterfaceWrapper) ListUsers(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUsersParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", ctx.QueryParams(), &params.Size)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter size: %s", err))
	}

	// ------------- Optional query parameter "username" -------------

	err = runtime.BindQueryParameter("form", true, false, "username", ctx.QueryParams(), &params.Username)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter username: %s", err))
	}

	// ------------- Optional query parameter "role" -------------

	err = runtime.BindQueryParameter("form", true, false, "role", ctx.QueryParams(), &params.Role)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter role: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListUsers(ctx, params)
	return err
}

// CreateUser converts echo context to params.
func (w *ServerInterfaceWrapper) CreateUser(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateUser(ctx)
	return err
}

// DeleteUser converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userId" -------------
	var userId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "userId", ctx.Param("userId"), &userId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteUser(ctx, userId)
	return err
}

// GetUser converts echo context to params.
func (w *ServerInterfaceWrapper) GetUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userId" -------------
	var userId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "userId", ctx.Param("userId"), &userId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUser(ctx, userId)
	return err
}

// UpdateUser converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userId" -------------
	var userId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "userId", ctx.Param("userId"), &userId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateUser(ctx, userId)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/audit", wrapper.SearchAuditLogs)
	router.POST(baseURL+"/auth/login", wrapper.Login)
	router.POST(baseURL+"/auth/logout", wrapper.Logout)
	router.GET(baseURL+"/me", wrapper.GetCurrentUser)
	router.GET(baseURL+"/oss", wrapper.ListOssComponents)
	router.POST(baseURL+"/oss", wrapper.CreateOssComponent)
	router.DELETE(baseURL+"/oss/:ossId", wrapper.DeprecateOssComponent)
	router.GET(baseURL+"/oss/:ossId", wrapper.GetOssComponent)
	router.PATCH(baseURL+"/oss/:ossId", wrapper.UpdateOssComponent)
	router.GET(baseURL+"/oss/:ossId/versions", wrapper.ListOssVersions)
	router.POST(baseURL+"/oss/:ossId/versions", wrapper.CreateOssVersion)
	router.DELETE(baseURL+"/oss/:ossId/versions/:versionId", wrapper.DeleteOssVersion)
	router.GET(baseURL+"/oss/:ossId/versions/:versionId", wrapper.GetOssVersion)
	router.PATCH(baseURL+"/oss/:ossId/versions/:versionId", wrapper.UpdateOssVersion)
	router.GET(baseURL+"/projects", wrapper.ListProjects)
	router.POST(baseURL+"/projects", wrapper.CreateProject)
	router.DELETE(baseURL+"/projects/:projectId", wrapper.DeleteProject)
	router.GET(baseURL+"/projects/:projectId", wrapper.GetProject)
	router.PATCH(baseURL+"/projects/:projectId", wrapper.UpdateProject)
	router.GET(baseURL+"/projects/:projectId/export", wrapper.ExportProjectArtifacts)
	router.GET(baseURL+"/projects/:projectId/usages", wrapper.ListProjectUsages)
	router.POST(baseURL+"/projects/:projectId/usages", wrapper.CreateProjectUsage)
	router.DELETE(baseURL+"/projects/:projectId/usages/:usageId", wrapper.DeleteProjectUsage)
	router.PATCH(baseURL+"/projects/:projectId/usages/:usageId", wrapper.UpdateProjectUsage)
	router.PATCH(baseURL+"/projects/:projectId/usages/:usageId/scope", wrapper.UpdateProjectUsageScope)
	router.GET(baseURL+"/scope/policy", wrapper.GetScopePolicy)
	router.PATCH(baseURL+"/scope/policy", wrapper.UpdateScopePolicy)
	router.GET(baseURL+"/tags", wrapper.ListTags)
	router.POST(baseURL+"/tags", wrapper.CreateTag)
	router.DELETE(baseURL+"/tags/:tagId", wrapper.DeleteTag)
	router.GET(baseURL+"/users", wrapper.ListUsers)
	router.POST(baseURL+"/users", wrapper.CreateUser)
	router.DELETE(baseURL+"/users/:userId", wrapper.DeleteUser)
	router.GET(baseURL+"/users/:userId", wrapper.GetUser)
	router.PATCH(baseURL+"/users/:userId", wrapper.UpdateUser)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"tr7/DQAA//92B6FUpq8AAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
