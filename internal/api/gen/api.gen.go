// Package gen provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package gen

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BasicAuthScopes = "basicAuth.Scopes"
)

// Defines values for Layer.
const (
	DB         Layer = "DB"
	DOC        Layer = "DOC"
	FRAMEWORK  Layer = "FRAMEWORK"
	LIB        Layer = "LIB"
	MIDDLEWARE Layer = "MIDDLEWARE"
	OS         Layer = "OS"
	OTHER      Layer = "OTHER"
	RUNTIME    Layer = "RUNTIME"
	TOOLBUILD  Layer = "TOOL_BUILD"
	TOOLDEV    Layer = "TOOL_DEV"
	TOOLTEST   Layer = "TOOL_TEST"
)

// Defines values for ReviewStatus.
const (
	Draft    ReviewStatus = "draft"
	Verified ReviewStatus = "verified"
)

// Defines values for Role.
const (
	ADMIN  Role = "ADMIN"
	EDITOR Role = "EDITOR"
	VIEWER Role = "VIEWER"
)

// Defines values for ScopeStatus.
const (
	INSCOPE      ScopeStatus = "IN_SCOPE"
	OUTSCOPE     ScopeStatus = "OUT_SCOPE"
	REVIEWNEEDED ScopeStatus = "REVIEW_NEEDED"
)

// Defines values for SupplierType.
const (
	INTERNALFORK SupplierType = "INTERNAL_FORK"
	REPACKAGE    SupplierType = "REPACKAGE"
	UPSTREAM     SupplierType = "UPSTREAM"
)

// Defines values for UsageRole.
const (
	BUILDONLY       UsageRole = "BUILD_ONLY"
	BUNDLEDBINARY   UsageRole = "BUNDLED_BINARY"
	BUNDLEDSOURCE   UsageRole = "BUNDLED_SOURCE"
	DEVONLY         UsageRole = "DEV_ONLY"
	DYNAMICLINK     UsageRole = "DYNAMIC_LINK"
	RUNTIMEREQUIRED UsageRole = "RUNTIME_REQUIRED"
	SERVERENV       UsageRole = "SERVER_ENV"
	STATICLINK      UsageRole = "STATIC_LINK"
	TESTONLY        UsageRole = "TEST_ONLY"
)

// Defines values for ExportProjectArtifactsParamsFormat.
const (
	Csv      ExportProjectArtifactsParamsFormat = "csv"
	SpdxJson ExportProjectArtifactsParamsFormat = "spdx-json"
)

// Layer OSS 技術レイヤ分類（OS=OS, LIB=ライブラリ 等）
type Layer string

// OssComponent OSS の論理的名称（バージョン共通情報）
type OssComponent struct {
	// CreatedAt 作成日時
	CreatedAt time.Time `json:"createdAt"`

	// DefaultUsageRole プロジェクト内での利用形態（配布対象か／工程限定か）
	DefaultUsageRole *UsageRole `json:"defaultUsageRole,omitempty"`

	// Deprecated 非推奨フラグ（新規利用抑止）
	Deprecated bool `json:"deprecated"`

	// Description 簡易説明 / メモ
	Description *string `json:"description"`

	// HomepageUrl 公式サイト URL
	HomepageUrl *string `json:"homepageUrl"`

	// Id OSSコンポーネント ID
	Id openapi_types.UUID `json:"id"`

	// Layers 技術レイヤ分類（複数指定可）
	Layers *[]Layer `json:"layers,omitempty"`

	// Name 表示名 / ユニーク（大文字小文字区別ポリシーは実装で決定）
	Name string `json:"name"`

	// NormalizedName 検索用正規化名称（小文字化・記号除去）
	NormalizedName *string `json:"normalizedName,omitempty"`

	// PrimaryLanguage 主言語（例: C, C++, Go, Java）
	PrimaryLanguage *string `json:"primaryLanguage"`

	// RepositoryUrl ソースリポジトリ（Git 等）URL
	RepositoryUrl *string `json:"repositoryUrl"`

	// Tags 付与タグ一覧
	Tags *[]Tag `json:"tags,omitempty"`

	// UpdatedAt 更新日時
	UpdatedAt time.Time `json:"updatedAt"`
}

// OssComponentCreateRequest OSSコンポーネント作成リクエスト
type OssComponentCreateRequest struct {
	// DefaultUsageRole プロジェクト内での利用形態（配布対象か／工程限定か）
	DefaultUsageRole *UsageRole `json:"defaultUsageRole,omitempty"`

	// Description 説明 / 備考
	Description *string `json:"description"`

	// HomepageUrl 公式サイト URL
	HomepageUrl *string `json:"homepageUrl"`

	// Layers 技術レイヤ配列
	Layers *[]Layer `json:"layers,omitempty"`

	// Name OSS 表示名
	Name string `json:"name"`

	// PrimaryLanguage 主言語
	PrimaryLanguage *string `json:"primaryLanguage"`

	// RepositoryUrl リポジトリ URL
	RepositoryUrl *string `json:"repositoryUrl"`

	// TagIds 初期付与するタグ ID 群
	TagIds *[]openapi_types.UUID `json:"tagIds,omitempty"`
}

// OssComponentUpdateRequest OSSコンポーネント更新リクエスト（部分）
type OssComponentUpdateRequest struct {
	// DefaultUsageRole プロジェクト内での利用形態（配布対象か／工程限定か）
	DefaultUsageRole *UsageRole `json:"defaultUsageRole,omitempty"`

	// Deprecated 非推奨フラグ
	Deprecated *bool `json:"deprecated,omitempty"`

	// Description 説明 / 備考
	Description *string `json:"description"`

	// HomepageUrl 公式サイト URL
	HomepageUrl *string `json:"homepageUrl"`

	// Layers 技術レイヤ配列
	Layers *[]Layer `json:"layers,omitempty"`

	// Name 新しい名称
	Name *string `json:"name,omitempty"`

	// PrimaryLanguage 主言語
	PrimaryLanguage *string `json:"primaryLanguage"`

	// RepositoryUrl リポジトリ URL
	RepositoryUrl *string `json:"repositoryUrl"`

	// TagIds 置換後のタグ ID 配列
	TagIds *[]openapi_types.UUID `json:"tagIds,omitempty"`
}

// OssVersion 個別バージョン情報
type OssVersion struct {
	// CpeList CPE 文字列配列（脆弱性紐付け用）
	CpeList *[]string `json:"cpeList,omitempty"`

	// CreatedAt 作成日時
	CreatedAt time.Time `json:"createdAt"`

	// ForkOriginUrl フォーク元 URL (INTERNAL_FORK の場合)
	ForkOriginUrl *string `json:"forkOriginUrl"`

	// HashSha256 配布アーカイブ等の SHA-256 ハッシュ
	HashSha256 *string `json:"hashSha256"`

	// Id バージョン ID
	Id openapi_types.UUID `json:"id"`

	// LastReviewedAt 最終レビュー日時
	LastReviewedAt *time.Time `json:"lastReviewedAt"`

	// LicenseConcluded 社内審査確定ライセンス式
	LicenseConcluded *string `json:"licenseConcluded"`

	// LicenseExpressionRaw SPDX 互換ライセンス式（上流取得時点）
	LicenseExpressionRaw *string `json:"licenseExpressionRaw"`

	// ModificationDescription 改変内容概要
	ModificationDescription *string `json:"modificationDescription"`

	// Modified 社内改変有無
	Modified bool `json:"modified"`

	// OssId 親 OSSコンポーネント ID
	OssId openapi_types.UUID `json:"ossId"`

	// Purl package-url (例: pkg:maven/...)
	Purl *string `json:"purl"`

	// ReleaseDate 上流リリース日
	ReleaseDate *openapi_types.Date `json:"releaseDate"`

	// ReviewStatus バージョンレビュー状態（draft=未承認, verified=確認済）
	ReviewStatus ReviewStatus `json:"reviewStatus"`

	// ScopeStatus 納品対象スコープ判定状態（IN_SCOPE=含む, OUT_SCOPE=除外, REVIEW_NEEDED=要判定）
	ScopeStatus ScopeStatus `json:"scopeStatus"`

	// SupplierType 取得・供給形態（フォークや再パッケージか）
	SupplierType *SupplierType `json:"supplierType,omitempty"`

	// UpdatedAt 更新日時
	UpdatedAt time.Time `json:"updatedAt"`

	// Version バージョン文字列 (SemVer 互換推奨)
	Version string `json:"version"`
}

// OssVersionCreateRequest バージョン作成リクエスト
type OssVersionCreateRequest struct {
	// CpeList CPE 配列
	CpeList *[]string `json:"cpeList,omitempty"`

	// ForkOriginUrl フォーク元 URL
	ForkOriginUrl *string `json:"forkOriginUrl"`

	// HashSha256 アーカイブ SHA-256
	HashSha256 *string `json:"hashSha256"`

	// LicenseExpressionRaw 生ライセンス式
	LicenseExpressionRaw *string `json:"licenseExpressionRaw"`

	// ModificationDescription 改変概要
	ModificationDescription *string `json:"modificationDescription"`

	// Modified 社内改変有無
	Modified *bool `json:"modified,omitempty"`

	// Purl package-url
	Purl *string `json:"purl"`

	// ReleaseDate リリース日
	ReleaseDate *openapi_types.Date `json:"releaseDate"`

	// SupplierType 取得・供給形態（フォークや再パッケージか）
	SupplierType *SupplierType `json:"supplierType,omitempty"`

	// Version バージョン文字列
	Version string `json:"version"`
}

// OssVersionUpdateRequest バージョン更新リクエスト（部分）
type OssVersionUpdateRequest struct {
	// CpeList CPE 配列
	CpeList *[]string `json:"cpeList,omitempty"`

	// ForkOriginUrl フォーク元 URL
	ForkOriginUrl *string `json:"forkOriginUrl"`

	// HashSha256 SHA-256 ハッシュ
	HashSha256 *string `json:"hashSha256"`

	// LicenseConcluded 確定ライセンス式
	LicenseConcluded *string `json:"licenseConcluded"`

	// LicenseExpressionRaw 生ライセンス式
	LicenseExpressionRaw *string `json:"licenseExpressionRaw"`

	// ModificationDescription 改変概要
	ModificationDescription *string `json:"modificationDescription"`

	// Modified 改変有無
	Modified *bool `json:"modified,omitempty"`

	// Purl package-url
	Purl *string `json:"purl"`

	// ReleaseDate リリース日
	ReleaseDate *openapi_types.Date `json:"releaseDate"`

	// ReviewStatus バージョンレビュー状態（draft=未承認, verified=確認済）
	ReviewStatus *ReviewStatus `json:"reviewStatus,omitempty"`

	// ScopeStatus 納品対象スコープ判定状態（IN_SCOPE=含む, OUT_SCOPE=除外, REVIEW_NEEDED=要判定）
	ScopeStatus *ScopeStatus `json:"scopeStatus,omitempty"`

	// SupplierType 取得・供給形態（フォークや再パッケージか）
	SupplierType *SupplierType `json:"supplierType,omitempty"`
}

// PagedResultOssComponent OSSコンポーネントページング結果
type PagedResultOssComponent struct {
	// Items 結果アイテム配列
	Items *[]OssComponent `json:"items,omitempty"`

	// Page 現在ページ (1 始まり)
	Page *int `json:"page,omitempty"`

	// Size ページサイズ
	Size *int `json:"size,omitempty"`

	// Total 総件数
	Total *int `json:"total,omitempty"`
}

// PagedResultOssVersion OSS バージョンページング結果
type PagedResultOssVersion struct {
	// Items 結果アイテム配列
	Items *[]OssVersion `json:"items,omitempty"`

	// Page 現在ページ
	Page *int `json:"page,omitempty"`

	// Size ページサイズ
	Size *int `json:"size,omitempty"`

	// Total 総件数
	Total *int `json:"total,omitempty"`
}

// PagedResultProject プロジェクト一覧ページング結果
type PagedResultProject struct {
	// Items 結果アイテム配列
	Items *[]Project `json:"items,omitempty"`

	// Page 現在ページ
	Page *int `json:"page,omitempty"`

	// Size ページサイズ
	Size *int `json:"size,omitempty"`

	// Total 総件数
	Total *int `json:"total,omitempty"`
}

// PagedResultProjectUsage プロジェクト利用レコードのページング結果
type PagedResultProjectUsage struct {
	// Items 結果アイテム配列
	Items *[]ProjectUsage `json:"items,omitempty"`

	// Page 現在ページ
	Page *int `json:"page,omitempty"`

	// Size ページサイズ
	Size *int `json:"size,omitempty"`

	// Total 総件数
	Total *int `json:"total,omitempty"`
}

// PagedResultUser ユーザー一覧ページング結果
type PagedResultUser struct {
	Items *[]User `json:"items,omitempty"`
	Page  *int    `json:"page,omitempty"`
	Size  *int    `json:"size,omitempty"`
	Total *int    `json:"total,omitempty"`
}

// Problem RFC 9457 / RFC 7807 型エラー応答ボディ
type Problem struct {
	// Code アプリケーション独自エラーコード
	Code *string `json:"code"`

	// Detail 追加詳細メッセージ
	Detail *string `json:"detail"`

	// Errors フィールド単位バリデーションエラー配列
	Errors *[]struct {
		// Field エラーが発生したフィールド名（JSON Pointer など）
		Field *string `json:"field,omitempty"`

		// Message フィールドに対するエラーメッセージ
		Message *string `json:"message,omitempty"`
	} `json:"errors,omitempty"`

	// Instance エラーが発生した具体的インスタンス URI（トレースID等）
	Instance *string `json:"instance"`

	// Status HTTP ステータスコード
	Status int `json:"status"`

	// Title エラーの概要メッセージ（人間可読）
	Title string `json:"title"`

	// Type 問題タイプ識別 URI（拡張分類用）
	Type *string `json:"type"`
}

// Project プロジェクト（納品単位）
type Project struct {
	// CreatedAt 作成日時
	CreatedAt time.Time `json:"createdAt"`

	// DeliveryDate 納品予定日
	DeliveryDate *openapi_types.Date `json:"deliveryDate"`

	// Department 担当部署
	Department *string `json:"department"`

	// Description 説明 / 備考
	Description *string `json:"description"`

	// Id プロジェクト ID
	Id openapi_types.UUID `json:"id"`

	// Manager 責任者 / 担当者名
	Manager *string `json:"manager"`

	// Name プロジェクト名称
	Name string `json:"name"`

	// OssUsageCount 紐付く OSS 利用件数集計
	OssUsageCount *int `json:"ossUsageCount,omitempty"`

	// ProjectCode 社内識別コード（ユニーク）
	ProjectCode string `json:"projectCode"`

	// UpdatedAt 更新日時
	UpdatedAt time.Time `json:"updatedAt"`
}

// ProjectCreateRequest プロジェクト作成リクエスト
type ProjectCreateRequest struct {
	// DeliveryDate 納品日
	DeliveryDate *openapi_types.Date `json:"deliveryDate"`

	// Department 部署
	Department *string `json:"department"`

	// Description 説明 / 備考
	Description *string `json:"description"`

	// Manager 責任者
	Manager *string `json:"manager"`

	// Name 名称
	Name string `json:"name"`

	// ProjectCode ユニークなプロジェクトコード
	ProjectCode string `json:"projectCode"`
}

// ProjectUpdateRequest プロジェクト更新リクエスト
type ProjectUpdateRequest struct {
	// DeliveryDate 納品日
	DeliveryDate *openapi_types.Date `json:"deliveryDate"`

	// Department 部署
	Department *string `json:"department"`

	// Description 説明 / 備考
	Description *string `json:"description"`

	// Manager 責任者
	Manager *string `json:"manager"`

	// Name 名称
	Name *string `json:"name,omitempty"`
}

// ProjectUsage プロジェクトにおける特定 OSS バージョンの利用レコード
type ProjectUsage struct {
	// AddedAt 登録日時
	AddedAt time.Time `json:"addedAt"`

	// DirectDependency 直接依存なら true (間接は false)
	DirectDependency bool `json:"directDependency"`

	// EvaluatedAt スコープ判定更新日時
	EvaluatedAt *time.Time `json:"evaluatedAt"`

	// EvaluatedBy 判定実施ユーザ
	EvaluatedBy *string `json:"evaluatedBy"`

	// Id 利用 ID
	Id openapi_types.UUID `json:"id"`

	// InclusionNote IN/OUT 判断理由メモ
	InclusionNote *string `json:"inclusionNote"`

	// OssId OSSコンポーネント ID (利便性重複)
	OssId openapi_types.UUID `json:"ossId"`

	// OssVersionId OSS バージョン ID
	OssVersionId openapi_types.UUID `json:"ossVersionId"`

	// ProjectId プロジェクト ID
	ProjectId openapi_types.UUID `json:"projectId"`

	// ScopeStatus 納品対象スコープ判定状態（IN_SCOPE=含む, OUT_SCOPE=除外, REVIEW_NEEDED=要判定）
	ScopeStatus ScopeStatus `json:"scopeStatus"`

	// UsageRole プロジェクト内での利用形態（配布対象か／工程限定か）
	UsageRole UsageRole `json:"usageRole"`
}

// ProjectUsageCreateRequest プロジェクト利用作成リクエスト
type ProjectUsageCreateRequest struct {
	// DirectDependency 直接依存なら true
	DirectDependency *bool `json:"directDependency,omitempty"`

	// InclusionNote 初期理由メモ
	InclusionNote *string `json:"inclusionNote"`

	// OssId OSSコンポーネント ID
	OssId openapi_types.UUID `json:"ossId"`

	// OssVersionId OSS バージョン ID
	OssVersionId openapi_types.UUID `json:"ossVersionId"`

	// UsageRole プロジェクト内での利用形態（配布対象か／工程限定か）
	UsageRole UsageRole `json:"usageRole"`
}

// ProjectUsageUpdateRequest プロジェクト利用更新リクエスト
type ProjectUsageUpdateRequest struct {
	// DirectDependency 直接依存フラグ
	DirectDependency *bool `json:"directDependency,omitempty"`

	// InclusionNote 理由メモ
	InclusionNote *string `json:"inclusionNote"`

	// OssVersionId 新しい OSS バージョン ID
	OssVersionId *openapi_types.UUID `json:"ossVersionId,omitempty"`

	// ScopeStatus 納品対象スコープ判定状態（IN_SCOPE=含む, OUT_SCOPE=除外, REVIEW_NEEDED=要判定）
	ScopeStatus *ScopeStatus `json:"scopeStatus,omitempty"`

	// UsageRole プロジェクト内での利用形態（配布対象か／工程限定か）
	UsageRole *UsageRole `json:"usageRole,omitempty"`
}

// ReviewStatus バージョンレビュー状態（draft=未承認, verified=確認済）
type ReviewStatus string

// Role アクセス制御ロール（ADMIN=全権, EDITOR=編集可, VIEWER=参照のみ）
type Role string

// ScopePolicy スコープ自動判定ポリシー設定
type ScopePolicy struct {
	// AutoMarkForksInScope INTERNAL_FORK を自動 IN_SCOPE 化するか
	AutoMarkForksInScope *bool `json:"autoMarkForksInScope,omitempty"`

	// Id ポリシー ID
	Id *openapi_types.UUID `json:"id,omitempty"`

	// RuntimeRequiredDefaultInScope RUNTIME_REQUIRED を自動 IN_SCOPE にするフラグ
	RuntimeRequiredDefaultInScope *bool `json:"runtimeRequiredDefaultInScope,omitempty"`

	// ServerEnvIncluded SERVER_ENV を IN_SCOPE とみなすか
	ServerEnvIncluded *bool `json:"serverEnvIncluded,omitempty"`

	// UpdatedAt 最終更新日時
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// UpdatedBy 更新ユーザ
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// ScopePolicyUpdateRequest スコープポリシー更新リクエスト
type ScopePolicyUpdateRequest struct {
	// AutoMarkForksInScope INTERNAL_FORK 自動 IN_SCOPE フラグ
	AutoMarkForksInScope *bool `json:"autoMarkForksInScope,omitempty"`

	// RuntimeRequiredDefaultInScope RUNTIME_REQUIRED 自動 IN_SCOPE フラグ
	RuntimeRequiredDefaultInScope *bool `json:"runtimeRequiredDefaultInScope,omitempty"`

	// ServerEnvIncluded SERVER_ENV を IN_SCOPE とするか
	ServerEnvIncluded *bool `json:"serverEnvIncluded,omitempty"`
}

// ScopeStatus 納品対象スコープ判定状態（IN_SCOPE=含む, OUT_SCOPE=除外, REVIEW_NEEDED=要判定）
type ScopeStatus string

// ScopeStatusUpdateRequest スコープ判定更新リクエスト
type ScopeStatusUpdateRequest struct {
	// ReasonCode 理由コード (マスタ化想定)
	ReasonCode *string `json:"reasonCode"`

	// ReasonNote 自由記述理由
	ReasonNote *string `json:"reasonNote"`

	// ScopeStatus 納品対象スコープ判定状態（IN_SCOPE=含む, OUT_SCOPE=除外, REVIEW_NEEDED=要判定）
	ScopeStatus ScopeStatus `json:"scopeStatus"`
}

// SupplierType 取得・供給形態（フォークや再パッケージか）
type SupplierType string

// Tag OSSコンポーネントに付与する分類タグ
type Tag struct {
	// CreatedAt 作成日時
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Id タグ ID
	Id openapi_types.UUID `json:"id"`

	// Name タグ名称（ユニーク）
	Name string `json:"name"`
}

// TagCreateRequest タグ作成リクエスト
type TagCreateRequest struct {
	// Name タグ名称
	Name string `json:"name"`
}

// UsageRole プロジェクト内での利用形態（配布対象か／工程限定か）
type UsageRole string

// User システム利用ユーザー情報
type User struct {
	// Active 有効/無効フラグ
	Active bool `json:"active"`

	// CreatedAt 作成日時
	CreatedAt time.Time `json:"createdAt"`

	// DisplayName 表示名
	DisplayName *string `json:"displayName,omitempty"`

	// Email メールアドレス
	Email *openapi_types.Email `json:"email"`

	// Id ユーザーID
	Id openapi_types.UUID `json:"id"`

	// Roles 付与ロール一覧
	Roles []Role `json:"roles"`

	// UpdatedAt 更新日時
	UpdatedAt time.Time `json:"updatedAt"`

	// Username ログインID（ユニーク）
	Username string `json:"username"`
}

// UserCreateRequest ユーザー作成リクエスト
type UserCreateRequest struct {
	// Active 有効化フラグ
	Active *bool `json:"active,omitempty"`

	// DisplayName 表示名
	DisplayName *string `json:"displayName,omitempty"`

	// Email メールアドレス
	Email *openapi_types.Email `json:"email"`

	// Password 初期パスワード（Basic想定、将来JWTなら不要）
	Password *string `json:"password,omitempty"`

	// Roles 付与するロール一覧
	Roles []Role `json:"roles"`

	// Username ログインID
	Username string `json:"username"`
}

// UserUpdateRequest ユーザー更新リクエスト（部分）
type UserUpdateRequest struct {
	// Active 有効/無効切替
	Active *bool `json:"active,omitempty"`

	// DisplayName 表示名
	DisplayName *string `json:"displayName,omitempty"`

	// Email メールアドレス
	Email *openapi_types.Email `json:"email"`

	// Password パスワード再設定用（任意）
	Password *string `json:"password,omitempty"`

	// Roles 付与ロール一覧（管理者のみ変更可）
	Roles *[]Role `json:"roles,omitempty"`
}

// PageParam defines model for PageParam.
type PageParam = int

// SizeParam defines model for SizeParam.
type SizeParam = int

// SortParam defines model for SortParam.
type SortParam = string

// BadRequest RFC 9457 / RFC 7807 型エラー応答ボディ
type BadRequest = Problem

// NotFound RFC 9457 / RFC 7807 型エラー応答ボディ
type NotFound = Problem

// SearchAuditLogsParams defines parameters for SearchAuditLogs.
type SearchAuditLogsParams struct {
	EntityType *string    `form:"entityType,omitempty" json:"entityType,omitempty"`
	EntityId   *string    `form:"entityId,omitempty" json:"entityId,omitempty"`
	From       *time.Time `form:"from,omitempty" json:"from,omitempty"`
	To         *time.Time `form:"to,omitempty" json:"to,omitempty"`
}

// ListOssComponentsParams defines parameters for ListOssComponents.
type ListOssComponentsParams struct {
	// Page 1 始まりのページ番号
	Page *PageParam `form:"page,omitempty" json:"page,omitempty"`

	// Size 1ページ件数 (最大 200)
	Size *SizeParam `form:"size,omitempty" json:"size,omitempty"`

	// Sort ソート指定 (例: name,asc / createdAt,desc)
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Name 部分一致
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Layers カンマ区切り Layer フィルタ (例 LIB,DB)
	Layers *string `form:"layers,omitempty" json:"layers,omitempty"`

	// Tag タグ名 (正確一致)
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// InScopeOnly true の場合 IN_SCOPE のバージョンを一つ以上持つもののみ
	InScopeOnly *bool `form:"inScopeOnly,omitempty" json:"inScopeOnly,omitempty"`
}

// ListOssVersionsParams defines parameters for ListOssVersions.
type ListOssVersionsParams struct {
	// Page 1 始まりのページ番号
	Page *PageParam `form:"page,omitempty" json:"page,omitempty"`

	// Size 1ページ件数 (最大 200)
	Size         *SizeParam    `form:"size,omitempty" json:"size,omitempty"`
	ReviewStatus *ReviewStatus `form:"reviewStatus,omitempty" json:"reviewStatus,omitempty"`
	ScopeStatus  *ScopeStatus  `form:"scopeStatus,omitempty" json:"scopeStatus,omitempty"`
}

// ListProjectsParams defines parameters for ListProjects.
type ListProjectsParams struct {
	// Page 1 始まりのページ番号
	Page *PageParam `form:"page,omitempty" json:"page,omitempty"`

	// Size 1ページ件数 (最大 200)
	Size *SizeParam `form:"size,omitempty" json:"size,omitempty"`
	Code *string    `form:"code,omitempty" json:"code,omitempty"`
	Name *string    `form:"name,omitempty" json:"name,omitempty"`
}

// ExportProjectArtifactsParams defines parameters for ExportProjectArtifacts.
type ExportProjectArtifactsParams struct {
	Format ExportProjectArtifactsParamsFormat `form:"format" json:"format"`
	Scopes *string                            `form:"scopes,omitempty" json:"scopes,omitempty"`
}

// ExportProjectArtifactsParamsFormat defines parameters for ExportProjectArtifacts.
type ExportProjectArtifactsParamsFormat string

// ListProjectUsagesParams defines parameters for ListProjectUsages.
type ListProjectUsagesParams struct {
	// Page 1 始まりのページ番号
	Page *PageParam `form:"page,omitempty" json:"page,omitempty"`

	// Size 1ページ件数 (最大 200)
	Size        *SizeParam   `form:"size,omitempty" json:"size,omitempty"`
	ScopeStatus *ScopeStatus `form:"scopeStatus,omitempty" json:"scopeStatus,omitempty"`
	UsageRole   *UsageRole   `form:"usageRole,omitempty" json:"usageRole,omitempty"`

	// Direct 直接依存のみ true
	Direct *bool `form:"direct,omitempty" json:"direct,omitempty"`
}

// ListUsersParams defines parameters for ListUsers.
type ListUsersParams struct {
	// Page 1 始まりのページ番号
	Page *PageParam `form:"page,omitempty" json:"page,omitempty"`

	// Size 1ページ件数 (最大 200)
	Size *SizeParam `form:"size,omitempty" json:"size,omitempty"`

	// Username 部分一致検索
	Username *string `form:"username,omitempty" json:"username,omitempty"`

	// Role ロールで絞り込み
	Role *Role `form:"role,omitempty" json:"role,omitempty"`
}

// CreateOssComponentJSONRequestBody defines body for CreateOssComponent for application/json ContentType.
type CreateOssComponentJSONRequestBody = OssComponentCreateRequest

// UpdateOssComponentJSONRequestBody defines body for UpdateOssComponent for application/json ContentType.
type UpdateOssComponentJSONRequestBody = OssComponentUpdateRequest

// CreateOssVersionJSONRequestBody defines body for CreateOssVersion for application/json ContentType.
type CreateOssVersionJSONRequestBody = OssVersionCreateRequest

// UpdateOssVersionJSONRequestBody defines body for UpdateOssVersion for application/json ContentType.
type UpdateOssVersionJSONRequestBody = OssVersionUpdateRequest

// CreateProjectJSONRequestBody defines body for CreateProject for application/json ContentType.
type CreateProjectJSONRequestBody = ProjectCreateRequest

// UpdateProjectJSONRequestBody defines body for UpdateProject for application/json ContentType.
type UpdateProjectJSONRequestBody = ProjectUpdateRequest

// CreateProjectUsageJSONRequestBody defines body for CreateProjectUsage for application/json ContentType.
type CreateProjectUsageJSONRequestBody = ProjectUsageCreateRequest

// UpdateProjectUsageJSONRequestBody defines body for UpdateProjectUsage for application/json ContentType.
type UpdateProjectUsageJSONRequestBody = ProjectUsageUpdateRequest

// UpdateProjectUsageScopeJSONRequestBody defines body for UpdateProjectUsageScope for application/json ContentType.
type UpdateProjectUsageScopeJSONRequestBody = ScopeStatusUpdateRequest

// UpdateScopePolicyJSONRequestBody defines body for UpdateScopePolicy for application/json ContentType.
type UpdateScopePolicyJSONRequestBody = ScopePolicyUpdateRequest

// CreateTagJSONRequestBody defines body for CreateTag for application/json ContentType.
type CreateTagJSONRequestBody = TagCreateRequest

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody = UserCreateRequest

// UpdateUserJSONRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody = UserUpdateRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// 監査ログ簡易検索 (Phase1簡易)
	// (GET /audit)
	SearchAuditLogs(ctx echo.Context, params SearchAuditLogsParams) error
	// 現在ログイン中ユーザー情報取得
	// (GET /me)
	GetCurrentUser(ctx echo.Context) error
	// OSSコンポーネント一覧取得
	// (GET /oss)
	ListOssComponents(ctx echo.Context, params ListOssComponentsParams) error
	// OSSコンポーネント作成
	// (POST /oss)
	CreateOssComponent(ctx echo.Context) error
	// OSSコンポーネントを非推奨 (deprecated=true) に設定
	// (DELETE /oss/{ossId})
	DeprecateOssComponent(ctx echo.Context, ossId openapi_types.UUID) error
	// OSSコンポーネント詳細
	// (GET /oss/{ossId})
	GetOssComponent(ctx echo.Context, ossId openapi_types.UUID) error
	// OSSコンポーネント更新 (部分)
	// (PATCH /oss/{ossId})
	UpdateOssComponent(ctx echo.Context, ossId openapi_types.UUID) error
	// 指定 OSS のバージョン一覧
	// (GET /oss/{ossId}/versions)
	ListOssVersions(ctx echo.Context, ossId openapi_types.UUID, params ListOssVersionsParams) error
	// バージョン追加
	// (POST /oss/{ossId}/versions)
	CreateOssVersion(ctx echo.Context, ossId openapi_types.UUID) error
	// バージョン削除 (論理/物理は実装方針による)
	// (DELETE /oss/{ossId}/versions/{versionId})
	DeleteOssVersion(ctx echo.Context, ossId openapi_types.UUID, versionId openapi_types.UUID) error
	// バージョン詳細
	// (GET /oss/{ossId}/versions/{versionId})
	GetOssVersion(ctx echo.Context, ossId openapi_types.UUID, versionId openapi_types.UUID) error
	// バージョン更新
	// (PATCH /oss/{ossId}/versions/{versionId})
	UpdateOssVersion(ctx echo.Context, ossId openapi_types.UUID, versionId openapi_types.UUID) error
	// プロジェクト一覧
	// (GET /projects)
	ListProjects(ctx echo.Context, params ListProjectsParams) error
	// プロジェクト作成
	// (POST /projects)
	CreateProject(ctx echo.Context) error
	// プロジェクト削除 (論理予定)
	// (DELETE /projects/{projectId})
	DeleteProject(ctx echo.Context, projectId openapi_types.UUID) error
	// プロジェクト詳細
	// (GET /projects/{projectId})
	GetProject(ctx echo.Context, projectId openapi_types.UUID) error
	// プロジェクト更新
	// (PATCH /projects/{projectId})
	UpdateProject(ctx echo.Context, projectId openapi_types.UUID) error
	// プロジェクト納品用エクスポート (プレースホルダ)
	// (GET /projects/{projectId}/export)
	ExportProjectArtifacts(ctx echo.Context, projectId openapi_types.UUID, params ExportProjectArtifactsParams) error
	// プロジェクト中利用 OSS 一覧
	// (GET /projects/{projectId}/usages)
	ListProjectUsages(ctx echo.Context, projectId openapi_types.UUID, params ListProjectUsagesParams) error
	// プロジェクト利用追加
	// (POST /projects/{projectId}/usages)
	CreateProjectUsage(ctx echo.Context, projectId openapi_types.UUID) error
	// 利用削除
	// (DELETE /projects/{projectId}/usages/{usageId})
	DeleteProjectUsage(ctx echo.Context, projectId openapi_types.UUID, usageId openapi_types.UUID) error
	// 利用情報更新
	// (PATCH /projects/{projectId}/usages/{usageId})
	UpdateProjectUsage(ctx echo.Context, projectId openapi_types.UUID, usageId openapi_types.UUID) error
	// スコープ判定更新
	// (PATCH /projects/{projectId}/usages/{usageId}/scope)
	UpdateProjectUsageScope(ctx echo.Context, projectId openapi_types.UUID, usageId openapi_types.UUID) error
	// 現行スコープポリシー取得
	// (GET /scope/policy)
	GetScopePolicy(ctx echo.Context) error
	// スコープポリシー更新 (管理者)
	// (PATCH /scope/policy)
	UpdateScopePolicy(ctx echo.Context) error
	// タグ一覧
	// (GET /tags)
	ListTags(ctx echo.Context) error
	// タグ作成
	// (POST /tags)
	CreateTag(ctx echo.Context) error
	// タグ削除
	// (DELETE /tags/{tagId})
	DeleteTag(ctx echo.Context, tagId openapi_types.UUID) error
	// ユーザー一覧
	// (GET /users)
	ListUsers(ctx echo.Context, params ListUsersParams) error
	// ユーザー作成
	// (POST /users)
	CreateUser(ctx echo.Context) error
	// ユーザー削除 (論理/物理は実装次第)
	// (DELETE /users/{userId})
	DeleteUser(ctx echo.Context, userId openapi_types.UUID) error
	// ユーザー詳細
	// (GET /users/{userId})
	GetUser(ctx echo.Context, userId openapi_types.UUID) error
	// ユーザー更新
	// (PATCH /users/{userId})
	UpdateUser(ctx echo.Context, userId openapi_types.UUID) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchAuditLogs converts echo context to params.
func (w *ServerInterfaceWrapper) SearchAuditLogs(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchAuditLogsParams
	// ------------- Optional query parameter "entityType" -------------

	err = runtime.BindQueryParameter("form", true, false, "entityType", ctx.QueryParams(), &params.EntityType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter entityType: %s", err))
	}

	// ------------- Optional query parameter "entityId" -------------

	err = runtime.BindQueryParameter("form", true, false, "entityId", ctx.QueryParams(), &params.EntityId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter entityId: %s", err))
	}

	// ------------- Optional query parameter "from" -------------

	err = runtime.BindQueryParameter("form", true, false, "from", ctx.QueryParams(), &params.From)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter from: %s", err))
	}

	// ------------- Optional query parameter "to" -------------

	err = runtime.BindQueryParameter("form", true, false, "to", ctx.QueryParams(), &params.To)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter to: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SearchAuditLogs(ctx, params)
	return err
}

// GetCurrentUser converts echo context to params.
func (w *ServerInterfaceWrapper) GetCurrentUser(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCurrentUser(ctx)
	return err
}

// ListOssComponents converts echo context to params.
func (w *ServerInterfaceWrapper) ListOssComponents(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListOssComponentsParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", ctx.QueryParams(), &params.Size)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter size: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "layers" -------------

	err = runtime.BindQueryParameter("form", true, false, "layers", ctx.QueryParams(), &params.Layers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter layers: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "inScopeOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "inScopeOnly", ctx.QueryParams(), &params.InScopeOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter inScopeOnly: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListOssComponents(ctx, params)
	return err
}

// CreateOssComponent converts echo context to params.
func (w *ServerInterfaceWrapper) CreateOssComponent(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateOssComponent(ctx)
	return err
}

// DeprecateOssComponent converts echo context to params.
func (w *ServerInterfaceWrapper) DeprecateOssComponent(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ossId" -------------
	var ossId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "ossId", ctx.Param("ossId"), &ossId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ossId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeprecateOssComponent(ctx, ossId)
	return err
}

// GetOssComponent converts echo context to params.
func (w *ServerInterfaceWrapper) GetOssComponent(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ossId" -------------
	var ossId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "ossId", ctx.Param("ossId"), &ossId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ossId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetOssComponent(ctx, ossId)
	return err
}

// UpdateOssComponent converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateOssComponent(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ossId" -------------
	var ossId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "ossId", ctx.Param("ossId"), &ossId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ossId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateOssComponent(ctx, ossId)
	return err
}

// ListOssVersions converts echo context to params.
func (w *ServerInterfaceWrapper) ListOssVersions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ossId" -------------
	var ossId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "ossId", ctx.Param("ossId"), &ossId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ossId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListOssVersionsParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", ctx.QueryParams(), &params.Size)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter size: %s", err))
	}

	// ------------- Optional query parameter "reviewStatus" -------------

	err = runtime.BindQueryParameter("form", true, false, "reviewStatus", ctx.QueryParams(), &params.ReviewStatus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter reviewStatus: %s", err))
	}

	// ------------- Optional query parameter "scopeStatus" -------------

	err = runtime.BindQueryParameter("form", true, false, "scopeStatus", ctx.QueryParams(), &params.ScopeStatus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scopeStatus: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListOssVersions(ctx, ossId, params)
	return err
}

// CreateOssVersion converts echo context to params.
func (w *ServerInterfaceWrapper) CreateOssVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ossId" -------------
	var ossId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "ossId", ctx.Param("ossId"), &ossId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ossId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateOssVersion(ctx, ossId)
	return err
}

// DeleteOssVersion converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteOssVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ossId" -------------
	var ossId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "ossId", ctx.Param("ossId"), &ossId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ossId: %s", err))
	}

	// ------------- Path parameter "versionId" -------------
	var versionId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "versionId", ctx.Param("versionId"), &versionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter versionId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteOssVersion(ctx, ossId, versionId)
	return err
}

// GetOssVersion converts echo context to params.
func (w *ServerInterfaceWrapper) GetOssVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ossId" -------------
	var ossId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "ossId", ctx.Param("ossId"), &ossId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ossId: %s", err))
	}

	// ------------- Path parameter "versionId" -------------
	var versionId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "versionId", ctx.Param("versionId"), &versionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter versionId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetOssVersion(ctx, ossId, versionId)
	return err
}

// UpdateOssVersion converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateOssVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ossId" -------------
	var ossId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "ossId", ctx.Param("ossId"), &ossId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ossId: %s", err))
	}

	// ------------- Path parameter "versionId" -------------
	var versionId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "versionId", ctx.Param("versionId"), &versionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter versionId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateOssVersion(ctx, ossId, versionId)
	return err
}

// ListProjects converts echo context to params.
func (w *ServerInterfaceWrapper) ListProjects(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListProjectsParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", ctx.QueryParams(), &params.Size)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter size: %s", err))
	}

	// ------------- Optional query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, false, "code", ctx.QueryParams(), &params.Code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListProjects(ctx, params)
	return err
}

// CreateProject converts echo context to params.
func (w *ServerInterfaceWrapper) CreateProject(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateProject(ctx)
	return err
}

// DeleteProject converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteProject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteProject(ctx, projectId)
	return err
}

// GetProject converts echo context to params.
func (w *ServerInterfaceWrapper) GetProject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetProject(ctx, projectId)
	return err
}

// UpdateProject converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateProject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateProject(ctx, projectId)
	return err
}

// ExportProjectArtifacts converts echo context to params.
func (w *ServerInterfaceWrapper) ExportProjectArtifacts(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ExportProjectArtifactsParams
	// ------------- Required query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, true, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "scopes" -------------

	err = runtime.BindQueryParameter("form", true, false, "scopes", ctx.QueryParams(), &params.Scopes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scopes: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ExportProjectArtifacts(ctx, projectId, params)
	return err
}

// ListProjectUsages converts echo context to params.
func (w *ServerInterfaceWrapper) ListProjectUsages(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListProjectUsagesParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", ctx.QueryParams(), &params.Size)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter size: %s", err))
	}

	// ------------- Optional query parameter "scopeStatus" -------------

	err = runtime.BindQueryParameter("form", true, false, "scopeStatus", ctx.QueryParams(), &params.ScopeStatus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scopeStatus: %s", err))
	}

	// ------------- Optional query parameter "usageRole" -------------

	err = runtime.BindQueryParameter("form", true, false, "usageRole", ctx.QueryParams(), &params.UsageRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter usageRole: %s", err))
	}

	// ------------- Optional query parameter "direct" -------------

	err = runtime.BindQueryParameter("form", true, false, "direct", ctx.QueryParams(), &params.Direct)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direct: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListProjectUsages(ctx, projectId, params)
	return err
}

// CreateProjectUsage converts echo context to params.
func (w *ServerInterfaceWrapper) CreateProjectUsage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateProjectUsage(ctx, projectId)
	return err
}

// DeleteProjectUsage converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteProjectUsage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	// ------------- Path parameter "usageId" -------------
	var usageId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "usageId", ctx.Param("usageId"), &usageId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter usageId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteProjectUsage(ctx, projectId, usageId)
	return err
}

// UpdateProjectUsage converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateProjectUsage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	// ------------- Path parameter "usageId" -------------
	var usageId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "usageId", ctx.Param("usageId"), &usageId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter usageId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateProjectUsage(ctx, projectId, usageId)
	return err
}

// UpdateProjectUsageScope converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateProjectUsageScope(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	// ------------- Path parameter "usageId" -------------
	var usageId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "usageId", ctx.Param("usageId"), &usageId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter usageId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateProjectUsageScope(ctx, projectId, usageId)
	return err
}

// GetScopePolicy converts echo context to params.
func (w *ServerInterfaceWrapper) GetScopePolicy(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScopePolicy(ctx)
	return err
}

// UpdateScopePolicy converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateScopePolicy(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateScopePolicy(ctx)
	return err
}

// ListTags converts echo context to params.
func (w *ServerInterfaceWrapper) ListTags(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListTags(ctx)
	return err
}

// CreateTag converts echo context to params.
func (w *ServerInterfaceWrapper) CreateTag(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateTag(ctx)
	return err
}

// DeleteTag converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteTag(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "tagId" -------------
	var tagId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "tagId", ctx.Param("tagId"), &tagId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tagId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteTag(ctx, tagId)
	return err
}

// ListUsers converts echo context to params.
func (w *ServerInterfaceWrapper) ListUsers(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUsersParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", ctx.QueryParams(), &params.Size)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter size: %s", err))
	}

	// ------------- Optional query parameter "username" -------------

	err = runtime.BindQueryParameter("form", true, false, "username", ctx.QueryParams(), &params.Username)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter username: %s", err))
	}

	// ------------- Optional query parameter "role" -------------

	err = runtime.BindQueryParameter("form", true, false, "role", ctx.QueryParams(), &params.Role)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter role: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListUsers(ctx, params)
	return err
}

// CreateUser converts echo context to params.
func (w *ServerInterfaceWrapper) CreateUser(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateUser(ctx)
	return err
}

// DeleteUser converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userId" -------------
	var userId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "userId", ctx.Param("userId"), &userId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteUser(ctx, userId)
	return err
}

// GetUser converts echo context to params.
func (w *ServerInterfaceWrapper) GetUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userId" -------------
	var userId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "userId", ctx.Param("userId"), &userId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUser(ctx, userId)
	return err
}

// UpdateUser converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userId" -------------
	var userId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "userId", ctx.Param("userId"), &userId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateUser(ctx, userId)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/audit", wrapper.SearchAuditLogs)
	router.GET(baseURL+"/me", wrapper.GetCurrentUser)
	router.GET(baseURL+"/oss", wrapper.ListOssComponents)
	router.POST(baseURL+"/oss", wrapper.CreateOssComponent)
	router.DELETE(baseURL+"/oss/:ossId", wrapper.DeprecateOssComponent)
	router.GET(baseURL+"/oss/:ossId", wrapper.GetOssComponent)
	router.PATCH(baseURL+"/oss/:ossId", wrapper.UpdateOssComponent)
	router.GET(baseURL+"/oss/:ossId/versions", wrapper.ListOssVersions)
	router.POST(baseURL+"/oss/:ossId/versions", wrapper.CreateOssVersion)
	router.DELETE(baseURL+"/oss/:ossId/versions/:versionId", wrapper.DeleteOssVersion)
	router.GET(baseURL+"/oss/:ossId/versions/:versionId", wrapper.GetOssVersion)
	router.PATCH(baseURL+"/oss/:ossId/versions/:versionId", wrapper.UpdateOssVersion)
	router.GET(baseURL+"/projects", wrapper.ListProjects)
	router.POST(baseURL+"/projects", wrapper.CreateProject)
	router.DELETE(baseURL+"/projects/:projectId", wrapper.DeleteProject)
	router.GET(baseURL+"/projects/:projectId", wrapper.GetProject)
	router.PATCH(baseURL+"/projects/:projectId", wrapper.UpdateProject)
	router.GET(baseURL+"/projects/:projectId/export", wrapper.ExportProjectArtifacts)
	router.GET(baseURL+"/projects/:projectId/usages", wrapper.ListProjectUsages)
	router.POST(baseURL+"/projects/:projectId/usages", wrapper.CreateProjectUsage)
	router.DELETE(baseURL+"/projects/:projectId/usages/:usageId", wrapper.DeleteProjectUsage)
	router.PATCH(baseURL+"/projects/:projectId/usages/:usageId", wrapper.UpdateProjectUsage)
	router.PATCH(baseURL+"/projects/:projectId/usages/:usageId/scope", wrapper.UpdateProjectUsageScope)
	router.GET(baseURL+"/scope/policy", wrapper.GetScopePolicy)
	router.PATCH(baseURL+"/scope/policy", wrapper.UpdateScopePolicy)
	router.GET(baseURL+"/tags", wrapper.ListTags)
	router.POST(baseURL+"/tags", wrapper.CreateTag)
	router.DELETE(baseURL+"/tags/:tagId", wrapper.DeleteTag)
	router.GET(baseURL+"/users", wrapper.ListUsers)
	router.POST(baseURL+"/users", wrapper.CreateUser)
	router.DELETE(baseURL+"/users/:userId", wrapper.DeleteUser)
	router.GET(baseURL+"/users/:userId", wrapper.GetUser)
	router.PATCH(baseURL+"/users/:userId", wrapper.UpdateUser)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"xHBOnAAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
