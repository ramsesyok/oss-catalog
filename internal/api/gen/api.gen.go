// Package gen provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package gen

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BasicAuthScopes = "basicAuth.Scopes"
)

// Defines values for Layer.
const (
	DB         Layer = "DB"
	DOC        Layer = "DOC"
	FRAMEWORK  Layer = "FRAMEWORK"
	LIB        Layer = "LIB"
	MIDDLEWARE Layer = "MIDDLEWARE"
	OS         Layer = "OS"
	OTHER      Layer = "OTHER"
	RUNTIME    Layer = "RUNTIME"
	TOOLBUILD  Layer = "TOOL_BUILD"
	TOOLDEV    Layer = "TOOL_DEV"
	TOOLTEST   Layer = "TOOL_TEST"
)

// Defines values for ReviewStatus.
const (
	Draft    ReviewStatus = "draft"
	Verified ReviewStatus = "verified"
)

// Defines values for ScopeStatus.
const (
	INSCOPE      ScopeStatus = "IN_SCOPE"
	OUTSCOPE     ScopeStatus = "OUT_SCOPE"
	REVIEWNEEDED ScopeStatus = "REVIEW_NEEDED"
)

// Defines values for SupplierType.
const (
	INTERNALFORK SupplierType = "INTERNAL_FORK"
	REPACKAGE    SupplierType = "REPACKAGE"
	UPSTREAM     SupplierType = "UPSTREAM"
)

// Defines values for UsageRole.
const (
	BUILDONLY       UsageRole = "BUILD_ONLY"
	BUNDLEDBINARY   UsageRole = "BUNDLED_BINARY"
	BUNDLEDSOURCE   UsageRole = "BUNDLED_SOURCE"
	DEVONLY         UsageRole = "DEV_ONLY"
	DYNAMICLINK     UsageRole = "DYNAMIC_LINK"
	RUNTIMEREQUIRED UsageRole = "RUNTIME_REQUIRED"
	SERVERENV       UsageRole = "SERVER_ENV"
	STATICLINK      UsageRole = "STATIC_LINK"
	TESTONLY        UsageRole = "TEST_ONLY"
)

// Defines values for ExportProjectArtifactsParamsFormat.
const (
	Csv      ExportProjectArtifactsParamsFormat = "csv"
	SpdxJson ExportProjectArtifactsParamsFormat = "spdx-json"
)

// Layer OSS 技術レイヤ分類（OS=OS, LIB=ライブラリ 等）
type Layer string

// OssComponent OSS の論理的名称（バージョン共通情報）
type OssComponent struct {
	// CreatedAt 作成日時
	CreatedAt time.Time `json:"createdAt"`

	// DefaultUsageRole プロジェクト内での利用形態（配布対象か／工程限定か）
	DefaultUsageRole *UsageRole `json:"defaultUsageRole,omitempty"`

	// Deprecated 非推奨フラグ（新規利用抑止）
	Deprecated bool `json:"deprecated"`

	// Description 簡易説明 / メモ
	Description *string `json:"description"`

	// HomepageUrl 公式サイト URL
	HomepageUrl *string `json:"homepageUrl"`

	// Id OSSコンポーネント ID
	Id openapi_types.UUID `json:"id"`

	// Layers 技術レイヤ分類（複数指定可）
	Layers *[]Layer `json:"layers,omitempty"`

	// Name 表示名 / ユニーク（大文字小文字区別ポリシーは実装で決定）
	Name string `json:"name"`

	// NormalizedName 検索用正規化名称（小文字化・記号除去）
	NormalizedName *string `json:"normalizedName,omitempty"`

	// PrimaryLanguage 主言語（例: C, C++, Go, Java）
	PrimaryLanguage *string `json:"primaryLanguage"`

	// RepositoryUrl ソースリポジトリ（Git 等）URL
	RepositoryUrl *string `json:"repositoryUrl"`

	// Tags 付与タグ一覧
	Tags *[]Tag `json:"tags,omitempty"`

	// UpdatedAt 更新日時
	UpdatedAt time.Time `json:"updatedAt"`
}

// OssComponentCreateRequest OSSコンポーネント作成リクエスト
type OssComponentCreateRequest struct {
	// DefaultUsageRole プロジェクト内での利用形態（配布対象か／工程限定か）
	DefaultUsageRole *UsageRole `json:"defaultUsageRole,omitempty"`

	// Description 説明 / 備考
	Description *string `json:"description"`

	// HomepageUrl 公式サイト URL
	HomepageUrl *string `json:"homepageUrl"`

	// Layers 技術レイヤ配列
	Layers *[]Layer `json:"layers,omitempty"`

	// Name OSS 表示名
	Name string `json:"name"`

	// PrimaryLanguage 主言語
	PrimaryLanguage *string `json:"primaryLanguage"`

	// RepositoryUrl リポジトリ URL
	RepositoryUrl *string `json:"repositoryUrl"`

	// TagIds 初期付与するタグ ID 群
	TagIds *[]openapi_types.UUID `json:"tagIds,omitempty"`
}

// OssComponentUpdateRequest OSSコンポーネント更新リクエスト（部分）
type OssComponentUpdateRequest struct {
	// DefaultUsageRole プロジェクト内での利用形態（配布対象か／工程限定か）
	DefaultUsageRole *UsageRole `json:"defaultUsageRole,omitempty"`

	// Deprecated 非推奨フラグ
	Deprecated *bool `json:"deprecated,omitempty"`

	// Description 説明 / 備考
	Description *string `json:"description"`

	// HomepageUrl 公式サイト URL
	HomepageUrl *string `json:"homepageUrl"`

	// Layers 技術レイヤ配列
	Layers *[]Layer `json:"layers,omitempty"`

	// Name 新しい名称
	Name *string `json:"name,omitempty"`

	// PrimaryLanguage 主言語
	PrimaryLanguage *string `json:"primaryLanguage"`

	// RepositoryUrl リポジトリ URL
	RepositoryUrl *string `json:"repositoryUrl"`

	// TagIds 置換後のタグ ID 配列
	TagIds *[]openapi_types.UUID `json:"tagIds,omitempty"`
}

// OssVersion 個別バージョン情報
type OssVersion struct {
	// CpeList CPE 文字列配列（脆弱性紐付け用）
	CpeList *[]string `json:"cpeList,omitempty"`

	// CreatedAt 作成日時
	CreatedAt time.Time `json:"createdAt"`

	// ForkOriginUrl フォーク元 URL (INTERNAL_FORK の場合)
	ForkOriginUrl *string `json:"forkOriginUrl"`

	// HashSha256 配布アーカイブ等の SHA-256 ハッシュ
	HashSha256 *string `json:"hashSha256"`

	// Id バージョン ID
	Id openapi_types.UUID `json:"id"`

	// LastReviewedAt 最終レビュー日時
	LastReviewedAt *time.Time `json:"lastReviewedAt"`

	// LicenseConcluded 社内審査確定ライセンス式
	LicenseConcluded *string `json:"licenseConcluded"`

	// LicenseExpressionRaw SPDX 互換ライセンス式（上流取得時点）
	LicenseExpressionRaw *string `json:"licenseExpressionRaw"`

	// ModificationDescription 改変内容概要
	ModificationDescription *string `json:"modificationDescription"`

	// Modified 社内改変有無
	Modified bool `json:"modified"`

	// OssId 親 OSSコンポーネント ID
	OssId openapi_types.UUID `json:"ossId"`

	// Purl package-url (例: pkg:maven/...)
	Purl *string `json:"purl"`

	// ReleaseDate 上流リリース日
	ReleaseDate *openapi_types.Date `json:"releaseDate"`

	// ReviewStatus バージョンレビュー状態（draft=未承認, verified=確認済）
	ReviewStatus ReviewStatus `json:"reviewStatus"`

	// ScopeStatus 納品対象スコープ判定状態（IN_SCOPE=含む, OUT_SCOPE=除外, REVIEW_NEEDED=要判定）
	ScopeStatus ScopeStatus `json:"scopeStatus"`

	// SupplierType 取得・供給形態（フォークや再パッケージか）
	SupplierType *SupplierType `json:"supplierType,omitempty"`

	// UpdatedAt 更新日時
	UpdatedAt time.Time `json:"updatedAt"`

	// Version バージョン文字列 (SemVer 互換推奨)
	Version string `json:"version"`
}

// OssVersionCreateRequest バージョン作成リクエスト
type OssVersionCreateRequest struct {
	// CpeList CPE 配列
	CpeList *[]string `json:"cpeList,omitempty"`

	// ForkOriginUrl フォーク元 URL
	ForkOriginUrl *string `json:"forkOriginUrl"`

	// HashSha256 アーカイブ SHA-256
	HashSha256 *string `json:"hashSha256"`

	// LicenseExpressionRaw 生ライセンス式
	LicenseExpressionRaw *string `json:"licenseExpressionRaw"`

	// ModificationDescription 改変概要
	ModificationDescription *string `json:"modificationDescription"`

	// Modified 社内改変有無
	Modified *bool `json:"modified,omitempty"`

	// Purl package-url
	Purl *string `json:"purl"`

	// ReleaseDate リリース日
	ReleaseDate *openapi_types.Date `json:"releaseDate"`

	// SupplierType 取得・供給形態（フォークや再パッケージか）
	SupplierType *SupplierType `json:"supplierType,omitempty"`

	// Version バージョン文字列
	Version string `json:"version"`
}

// OssVersionUpdateRequest バージョン更新リクエスト（部分）
type OssVersionUpdateRequest struct {
	// CpeList CPE 配列
	CpeList *[]string `json:"cpeList,omitempty"`

	// ForkOriginUrl フォーク元 URL
	ForkOriginUrl *string `json:"forkOriginUrl"`

	// HashSha256 SHA-256 ハッシュ
	HashSha256 *string `json:"hashSha256"`

	// LicenseConcluded 確定ライセンス式
	LicenseConcluded *string `json:"licenseConcluded"`

	// LicenseExpressionRaw 生ライセンス式
	LicenseExpressionRaw *string `json:"licenseExpressionRaw"`

	// ModificationDescription 改変概要
	ModificationDescription *string `json:"modificationDescription"`

	// Modified 改変有無
	Modified *bool `json:"modified,omitempty"`

	// Purl package-url
	Purl *string `json:"purl"`

	// ReleaseDate リリース日
	ReleaseDate *openapi_types.Date `json:"releaseDate"`

	// ReviewStatus バージョンレビュー状態（draft=未承認, verified=確認済）
	ReviewStatus *ReviewStatus `json:"reviewStatus,omitempty"`

	// ScopeStatus 納品対象スコープ判定状態（IN_SCOPE=含む, OUT_SCOPE=除外, REVIEW_NEEDED=要判定）
	ScopeStatus *ScopeStatus `json:"scopeStatus,omitempty"`

	// SupplierType 取得・供給形態（フォークや再パッケージか）
	SupplierType *SupplierType `json:"supplierType,omitempty"`
}

// PagedResultOssComponent OSSコンポーネントページング結果
type PagedResultOssComponent struct {
	// Items 結果アイテム配列
	Items *[]OssComponent `json:"items,omitempty"`

	// Page 現在ページ (1 始まり)
	Page *int `json:"page,omitempty"`

	// Size ページサイズ
	Size *int `json:"size,omitempty"`

	// Total 総件数
	Total *int `json:"total,omitempty"`
}

// PagedResultOssVersion OSS バージョンページング結果
type PagedResultOssVersion struct {
	// Items 結果アイテム配列
	Items *[]OssVersion `json:"items,omitempty"`

	// Page 現在ページ
	Page *int `json:"page,omitempty"`

	// Size ページサイズ
	Size *int `json:"size,omitempty"`

	// Total 総件数
	Total *int `json:"total,omitempty"`
}

// PagedResultProject プロジェクト一覧ページング結果
type PagedResultProject struct {
	// Items 結果アイテム配列
	Items *[]Project `json:"items,omitempty"`

	// Page 現在ページ
	Page *int `json:"page,omitempty"`

	// Size ページサイズ
	Size *int `json:"size,omitempty"`

	// Total 総件数
	Total *int `json:"total,omitempty"`
}

// PagedResultProjectUsage プロジェクト利用レコードのページング結果
type PagedResultProjectUsage struct {
	// Items 結果アイテム配列
	Items *[]ProjectUsage `json:"items,omitempty"`

	// Page 現在ページ
	Page *int `json:"page,omitempty"`

	// Size ページサイズ
	Size *int `json:"size,omitempty"`

	// Total 総件数
	Total *int `json:"total,omitempty"`
}

// Problem RFC 9457 / RFC 7807 型エラー応答ボディ
type Problem struct {
	// Code アプリケーション独自エラーコード
	Code *string `json:"code"`

	// Detail 追加詳細メッセージ
	Detail *string `json:"detail"`

	// Errors フィールド単位バリデーションエラー配列
	Errors *[]struct {
		// Field エラーが発生したフィールド名（JSON Pointer など）
		Field *string `json:"field,omitempty"`

		// Message フィールドに対するエラーメッセージ
		Message *string `json:"message,omitempty"`
	} `json:"errors,omitempty"`

	// Instance エラーが発生した具体的インスタンス URI（トレースID等）
	Instance *string `json:"instance"`

	// Status HTTP ステータスコード
	Status int `json:"status"`

	// Title エラーの概要メッセージ（人間可読）
	Title string `json:"title"`

	// Type 問題タイプ識別 URI（拡張分類用）
	Type *string `json:"type"`
}

// Project プロジェクト（納品単位）
type Project struct {
	// CreatedAt 作成日時
	CreatedAt time.Time `json:"createdAt"`

	// DeliveryDate 納品予定日
	DeliveryDate *openapi_types.Date `json:"deliveryDate"`

	// Department 担当部署
	Department *string `json:"department"`

	// Description 説明 / 備考
	Description *string `json:"description"`

	// Id プロジェクト ID
	Id openapi_types.UUID `json:"id"`

	// Manager 責任者 / 担当者名
	Manager *string `json:"manager"`

	// Name プロジェクト名称
	Name string `json:"name"`

	// OssUsageCount 紐付く OSS 利用件数集計
	OssUsageCount *int `json:"ossUsageCount,omitempty"`

	// ProjectCode 社内識別コード（ユニーク）
	ProjectCode string `json:"projectCode"`

	// UpdatedAt 更新日時
	UpdatedAt time.Time `json:"updatedAt"`
}

// ProjectCreateRequest プロジェクト作成リクエスト
type ProjectCreateRequest struct {
	// DeliveryDate 納品日
	DeliveryDate *openapi_types.Date `json:"deliveryDate"`

	// Department 部署
	Department *string `json:"department"`

	// Description 説明 / 備考
	Description *string `json:"description"`

	// Manager 責任者
	Manager *string `json:"manager"`

	// Name 名称
	Name string `json:"name"`

	// ProjectCode ユニークなプロジェクトコード
	ProjectCode string `json:"projectCode"`
}

// ProjectUpdateRequest プロジェクト更新リクエスト
type ProjectUpdateRequest struct {
	// DeliveryDate 納品日
	DeliveryDate *openapi_types.Date `json:"deliveryDate"`

	// Department 部署
	Department *string `json:"department"`

	// Description 説明 / 備考
	Description *string `json:"description"`

	// Manager 責任者
	Manager *string `json:"manager"`

	// Name 名称
	Name *string `json:"name,omitempty"`
}

// ProjectUsage プロジェクトにおける特定 OSS バージョンの利用レコード
type ProjectUsage struct {
	// AddedAt 登録日時
	AddedAt time.Time `json:"addedAt"`

	// DirectDependency 直接依存なら true (間接は false)
	DirectDependency bool `json:"directDependency"`

	// EvaluatedAt スコープ判定更新日時
	EvaluatedAt *time.Time `json:"evaluatedAt"`

	// EvaluatedBy 判定実施ユーザ
	EvaluatedBy *string `json:"evaluatedBy"`

	// Id 利用 ID
	Id openapi_types.UUID `json:"id"`

	// InclusionNote IN/OUT 判断理由メモ
	InclusionNote *string `json:"inclusionNote"`

	// OssId OSSコンポーネント ID (利便性重複)
	OssId openapi_types.UUID `json:"ossId"`

	// OssVersionId OSS バージョン ID
	OssVersionId openapi_types.UUID `json:"ossVersionId"`

	// ProjectId プロジェクト ID
	ProjectId openapi_types.UUID `json:"projectId"`

	// ScopeStatus 納品対象スコープ判定状態（IN_SCOPE=含む, OUT_SCOPE=除外, REVIEW_NEEDED=要判定）
	ScopeStatus ScopeStatus `json:"scopeStatus"`

	// UsageRole プロジェクト内での利用形態（配布対象か／工程限定か）
	UsageRole UsageRole `json:"usageRole"`
}

// ProjectUsageCreateRequest プロジェクト利用作成リクエスト
type ProjectUsageCreateRequest struct {
	// DirectDependency 直接依存なら true
	DirectDependency *bool `json:"directDependency,omitempty"`

	// InclusionNote 初期理由メモ
	InclusionNote *string `json:"inclusionNote"`

	// OssId OSSコンポーネント ID
	OssId openapi_types.UUID `json:"ossId"`

	// OssVersionId OSS バージョン ID
	OssVersionId openapi_types.UUID `json:"ossVersionId"`

	// UsageRole プロジェクト内での利用形態（配布対象か／工程限定か）
	UsageRole UsageRole `json:"usageRole"`
}

// ProjectUsageUpdateRequest プロジェクト利用更新リクエスト
type ProjectUsageUpdateRequest struct {
	// DirectDependency 直接依存フラグ
	DirectDependency *bool `json:"directDependency,omitempty"`

	// InclusionNote 理由メモ
	InclusionNote *string `json:"inclusionNote"`

	// OssVersionId 新しい OSS バージョン ID
	OssVersionId *openapi_types.UUID `json:"ossVersionId,omitempty"`

	// ScopeStatus 納品対象スコープ判定状態（IN_SCOPE=含む, OUT_SCOPE=除外, REVIEW_NEEDED=要判定）
	ScopeStatus *ScopeStatus `json:"scopeStatus,omitempty"`

	// UsageRole プロジェクト内での利用形態（配布対象か／工程限定か）
	UsageRole *UsageRole `json:"usageRole,omitempty"`
}

// ReviewStatus バージョンレビュー状態（draft=未承認, verified=確認済）
type ReviewStatus string

// ScopePolicy スコープ自動判定ポリシー設定
type ScopePolicy struct {
	// AutoMarkForksInScope INTERNAL_FORK を自動 IN_SCOPE 化するか
	AutoMarkForksInScope *bool `json:"autoMarkForksInScope,omitempty"`

	// Id ポリシー ID
	Id *openapi_types.UUID `json:"id,omitempty"`

	// RuntimeRequiredDefaultInScope RUNTIME_REQUIRED を自動 IN_SCOPE にするフラグ
	RuntimeRequiredDefaultInScope *bool `json:"runtimeRequiredDefaultInScope,omitempty"`

	// ServerEnvIncluded SERVER_ENV を IN_SCOPE とみなすか
	ServerEnvIncluded *bool `json:"serverEnvIncluded,omitempty"`

	// UpdatedAt 最終更新日時
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// UpdatedBy 更新ユーザ
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// ScopePolicyUpdateRequest スコープポリシー更新リクエスト
type ScopePolicyUpdateRequest struct {
	// AutoMarkForksInScope INTERNAL_FORK 自動 IN_SCOPE フラグ
	AutoMarkForksInScope *bool `json:"autoMarkForksInScope,omitempty"`

	// RuntimeRequiredDefaultInScope RUNTIME_REQUIRED 自動 IN_SCOPE フラグ
	RuntimeRequiredDefaultInScope *bool `json:"runtimeRequiredDefaultInScope,omitempty"`

	// ServerEnvIncluded SERVER_ENV を IN_SCOPE とするか
	ServerEnvIncluded *bool `json:"serverEnvIncluded,omitempty"`
}

// ScopeStatus 納品対象スコープ判定状態（IN_SCOPE=含む, OUT_SCOPE=除外, REVIEW_NEEDED=要判定）
type ScopeStatus string

// ScopeStatusUpdateRequest スコープ判定更新リクエスト
type ScopeStatusUpdateRequest struct {
	// ReasonCode 理由コード (マスタ化想定)
	ReasonCode *string `json:"reasonCode"`

	// ReasonNote 自由記述理由
	ReasonNote *string `json:"reasonNote"`

	// ScopeStatus 納品対象スコープ判定状態（IN_SCOPE=含む, OUT_SCOPE=除外, REVIEW_NEEDED=要判定）
	ScopeStatus ScopeStatus `json:"scopeStatus"`
}

// SupplierType 取得・供給形態（フォークや再パッケージか）
type SupplierType string

// Tag OSSコンポーネントに付与する分類タグ
type Tag struct {
	// CreatedAt 作成日時
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Id タグ ID
	Id openapi_types.UUID `json:"id"`

	// Name タグ名称（ユニーク）
	Name string `json:"name"`
}

// TagCreateRequest タグ作成リクエスト
type TagCreateRequest struct {
	// Name タグ名称
	Name string `json:"name"`
}

// UsageRole プロジェクト内での利用形態（配布対象か／工程限定か）
type UsageRole string

// PageParam defines model for PageParam.
type PageParam = int

// SizeParam defines model for SizeParam.
type SizeParam = int

// SortParam defines model for SortParam.
type SortParam = string

// BadRequest RFC 9457 / RFC 7807 型エラー応答ボディ
type BadRequest = Problem

// NotFound RFC 9457 / RFC 7807 型エラー応答ボディ
type NotFound = Problem

// SearchAuditLogsParams defines parameters for SearchAuditLogs.
type SearchAuditLogsParams struct {
	EntityType *string    `form:"entityType,omitempty" json:"entityType,omitempty"`
	EntityId   *string    `form:"entityId,omitempty" json:"entityId,omitempty"`
	From       *time.Time `form:"from,omitempty" json:"from,omitempty"`
	To         *time.Time `form:"to,omitempty" json:"to,omitempty"`
}

// ListOssComponentsParams defines parameters for ListOssComponents.
type ListOssComponentsParams struct {
	// Page 1 始まりのページ番号
	Page *PageParam `form:"page,omitempty" json:"page,omitempty"`

	// Size 1ページ件数 (最大 200)
	Size *SizeParam `form:"size,omitempty" json:"size,omitempty"`

	// Sort ソート指定 (例: name,asc / createdAt,desc)
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Name 部分一致
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Layers カンマ区切り Layer フィルタ (例 LIB,DB)
	Layers *string `form:"layers,omitempty" json:"layers,omitempty"`

	// Tag タグ名 (正確一致)
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// InScopeOnly true の場合 IN_SCOPE のバージョンを一つ以上持つもののみ
	InScopeOnly *bool `form:"inScopeOnly,omitempty" json:"inScopeOnly,omitempty"`
}

// ListOssVersionsParams defines parameters for ListOssVersions.
type ListOssVersionsParams struct {
	// Page 1 始まりのページ番号
	Page *PageParam `form:"page,omitempty" json:"page,omitempty"`

	// Size 1ページ件数 (最大 200)
	Size         *SizeParam    `form:"size,omitempty" json:"size,omitempty"`
	ReviewStatus *ReviewStatus `form:"reviewStatus,omitempty" json:"reviewStatus,omitempty"`
	ScopeStatus  *ScopeStatus  `form:"scopeStatus,omitempty" json:"scopeStatus,omitempty"`
}

// ListProjectsParams defines parameters for ListProjects.
type ListProjectsParams struct {
	// Page 1 始まりのページ番号
	Page *PageParam `form:"page,omitempty" json:"page,omitempty"`

	// Size 1ページ件数 (最大 200)
	Size *SizeParam `form:"size,omitempty" json:"size,omitempty"`
	Code *string    `form:"code,omitempty" json:"code,omitempty"`
	Name *string    `form:"name,omitempty" json:"name,omitempty"`
}

// ExportProjectArtifactsParams defines parameters for ExportProjectArtifacts.
type ExportProjectArtifactsParams struct {
	Format ExportProjectArtifactsParamsFormat `form:"format" json:"format"`
	Scopes *string                            `form:"scopes,omitempty" json:"scopes,omitempty"`
}

// ExportProjectArtifactsParamsFormat defines parameters for ExportProjectArtifacts.
type ExportProjectArtifactsParamsFormat string

// ListProjectUsagesParams defines parameters for ListProjectUsages.
type ListProjectUsagesParams struct {
	// Page 1 始まりのページ番号
	Page *PageParam `form:"page,omitempty" json:"page,omitempty"`

	// Size 1ページ件数 (最大 200)
	Size        *SizeParam   `form:"size,omitempty" json:"size,omitempty"`
	ScopeStatus *ScopeStatus `form:"scopeStatus,omitempty" json:"scopeStatus,omitempty"`
	UsageRole   *UsageRole   `form:"usageRole,omitempty" json:"usageRole,omitempty"`

	// Direct 直接依存のみ true
	Direct *bool `form:"direct,omitempty" json:"direct,omitempty"`
}

// CreateOssComponentJSONRequestBody defines body for CreateOssComponent for application/json ContentType.
type CreateOssComponentJSONRequestBody = OssComponentCreateRequest

// UpdateOssComponentJSONRequestBody defines body for UpdateOssComponent for application/json ContentType.
type UpdateOssComponentJSONRequestBody = OssComponentUpdateRequest

// CreateOssVersionJSONRequestBody defines body for CreateOssVersion for application/json ContentType.
type CreateOssVersionJSONRequestBody = OssVersionCreateRequest

// UpdateOssVersionJSONRequestBody defines body for UpdateOssVersion for application/json ContentType.
type UpdateOssVersionJSONRequestBody = OssVersionUpdateRequest

// CreateProjectJSONRequestBody defines body for CreateProject for application/json ContentType.
type CreateProjectJSONRequestBody = ProjectCreateRequest

// UpdateProjectJSONRequestBody defines body for UpdateProject for application/json ContentType.
type UpdateProjectJSONRequestBody = ProjectUpdateRequest

// CreateProjectUsageJSONRequestBody defines body for CreateProjectUsage for application/json ContentType.
type CreateProjectUsageJSONRequestBody = ProjectUsageCreateRequest

// UpdateProjectUsageJSONRequestBody defines body for UpdateProjectUsage for application/json ContentType.
type UpdateProjectUsageJSONRequestBody = ProjectUsageUpdateRequest

// UpdateProjectUsageScopeJSONRequestBody defines body for UpdateProjectUsageScope for application/json ContentType.
type UpdateProjectUsageScopeJSONRequestBody = ScopeStatusUpdateRequest

// UpdateScopePolicyJSONRequestBody defines body for UpdateScopePolicy for application/json ContentType.
type UpdateScopePolicyJSONRequestBody = ScopePolicyUpdateRequest

// CreateTagJSONRequestBody defines body for CreateTag for application/json ContentType.
type CreateTagJSONRequestBody = TagCreateRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// 監査ログ簡易検索 (Phase1簡易)
	// (GET /audit)
	SearchAuditLogs(ctx echo.Context, params SearchAuditLogsParams) error
	// OSSコンポーネント一覧取得
	// (GET /oss)
	ListOssComponents(ctx echo.Context, params ListOssComponentsParams) error
	// OSSコンポーネント作成
	// (POST /oss)
	CreateOssComponent(ctx echo.Context) error
	// OSSコンポーネントを非推奨 (deprecated=true) に設定
	// (DELETE /oss/{ossId})
	DeprecateOssComponent(ctx echo.Context, ossId openapi_types.UUID) error
	// OSSコンポーネント詳細
	// (GET /oss/{ossId})
	GetOssComponent(ctx echo.Context, ossId openapi_types.UUID) error
	// OSSコンポーネント更新 (部分)
	// (PATCH /oss/{ossId})
	UpdateOssComponent(ctx echo.Context, ossId openapi_types.UUID) error
	// 指定 OSS のバージョン一覧
	// (GET /oss/{ossId}/versions)
	ListOssVersions(ctx echo.Context, ossId openapi_types.UUID, params ListOssVersionsParams) error
	// バージョン追加
	// (POST /oss/{ossId}/versions)
	CreateOssVersion(ctx echo.Context, ossId openapi_types.UUID) error
	// バージョン削除 (論理/物理は実装方針による)
	// (DELETE /oss/{ossId}/versions/{versionId})
	DeleteOssVersion(ctx echo.Context, ossId openapi_types.UUID, versionId openapi_types.UUID) error
	// バージョン詳細
	// (GET /oss/{ossId}/versions/{versionId})
	GetOssVersion(ctx echo.Context, ossId openapi_types.UUID, versionId openapi_types.UUID) error
	// バージョン更新
	// (PATCH /oss/{ossId}/versions/{versionId})
	UpdateOssVersion(ctx echo.Context, ossId openapi_types.UUID, versionId openapi_types.UUID) error
	// プロジェクト一覧
	// (GET /projects)
	ListProjects(ctx echo.Context, params ListProjectsParams) error
	// プロジェクト作成
	// (POST /projects)
	CreateProject(ctx echo.Context) error
	// プロジェクト削除 (論理予定)
	// (DELETE /projects/{projectId})
	DeleteProject(ctx echo.Context, projectId openapi_types.UUID) error
	// プロジェクト詳細
	// (GET /projects/{projectId})
	GetProject(ctx echo.Context, projectId openapi_types.UUID) error
	// プロジェクト更新
	// (PATCH /projects/{projectId})
	UpdateProject(ctx echo.Context, projectId openapi_types.UUID) error
	// プロジェクト納品用エクスポート (プレースホルダ)
	// (GET /projects/{projectId}/export)
	ExportProjectArtifacts(ctx echo.Context, projectId openapi_types.UUID, params ExportProjectArtifactsParams) error
	// プロジェクト中利用 OSS 一覧
	// (GET /projects/{projectId}/usages)
	ListProjectUsages(ctx echo.Context, projectId openapi_types.UUID, params ListProjectUsagesParams) error
	// プロジェクト利用追加
	// (POST /projects/{projectId}/usages)
	CreateProjectUsage(ctx echo.Context, projectId openapi_types.UUID) error
	// 利用削除
	// (DELETE /projects/{projectId}/usages/{usageId})
	DeleteProjectUsage(ctx echo.Context, projectId openapi_types.UUID, usageId openapi_types.UUID) error
	// 利用情報更新
	// (PATCH /projects/{projectId}/usages/{usageId})
	UpdateProjectUsage(ctx echo.Context, projectId openapi_types.UUID, usageId openapi_types.UUID) error
	// スコープ判定更新
	// (PATCH /projects/{projectId}/usages/{usageId}/scope)
	UpdateProjectUsageScope(ctx echo.Context, projectId openapi_types.UUID, usageId openapi_types.UUID) error
	// 現行スコープポリシー取得
	// (GET /scope/policy)
	GetScopePolicy(ctx echo.Context) error
	// スコープポリシー更新 (管理者)
	// (PATCH /scope/policy)
	UpdateScopePolicy(ctx echo.Context) error
	// タグ一覧
	// (GET /tags)
	ListTags(ctx echo.Context) error
	// タグ作成
	// (POST /tags)
	CreateTag(ctx echo.Context) error
	// タグ削除
	// (DELETE /tags/{tagId})
	DeleteTag(ctx echo.Context, tagId openapi_types.UUID) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchAuditLogs converts echo context to params.
func (w *ServerInterfaceWrapper) SearchAuditLogs(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchAuditLogsParams
	// ------------- Optional query parameter "entityType" -------------

	err = runtime.BindQueryParameter("form", true, false, "entityType", ctx.QueryParams(), &params.EntityType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter entityType: %s", err))
	}

	// ------------- Optional query parameter "entityId" -------------

	err = runtime.BindQueryParameter("form", true, false, "entityId", ctx.QueryParams(), &params.EntityId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter entityId: %s", err))
	}

	// ------------- Optional query parameter "from" -------------

	err = runtime.BindQueryParameter("form", true, false, "from", ctx.QueryParams(), &params.From)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter from: %s", err))
	}

	// ------------- Optional query parameter "to" -------------

	err = runtime.BindQueryParameter("form", true, false, "to", ctx.QueryParams(), &params.To)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter to: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SearchAuditLogs(ctx, params)
	return err
}

// ListOssComponents converts echo context to params.
func (w *ServerInterfaceWrapper) ListOssComponents(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListOssComponentsParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", ctx.QueryParams(), &params.Size)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter size: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "layers" -------------

	err = runtime.BindQueryParameter("form", true, false, "layers", ctx.QueryParams(), &params.Layers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter layers: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "inScopeOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "inScopeOnly", ctx.QueryParams(), &params.InScopeOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter inScopeOnly: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListOssComponents(ctx, params)
	return err
}

// CreateOssComponent converts echo context to params.
func (w *ServerInterfaceWrapper) CreateOssComponent(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateOssComponent(ctx)
	return err
}

// DeprecateOssComponent converts echo context to params.
func (w *ServerInterfaceWrapper) DeprecateOssComponent(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ossId" -------------
	var ossId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "ossId", ctx.Param("ossId"), &ossId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ossId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeprecateOssComponent(ctx, ossId)
	return err
}

// GetOssComponent converts echo context to params.
func (w *ServerInterfaceWrapper) GetOssComponent(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ossId" -------------
	var ossId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "ossId", ctx.Param("ossId"), &ossId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ossId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetOssComponent(ctx, ossId)
	return err
}

// UpdateOssComponent converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateOssComponent(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ossId" -------------
	var ossId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "ossId", ctx.Param("ossId"), &ossId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ossId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateOssComponent(ctx, ossId)
	return err
}

// ListOssVersions converts echo context to params.
func (w *ServerInterfaceWrapper) ListOssVersions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ossId" -------------
	var ossId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "ossId", ctx.Param("ossId"), &ossId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ossId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListOssVersionsParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", ctx.QueryParams(), &params.Size)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter size: %s", err))
	}

	// ------------- Optional query parameter "reviewStatus" -------------

	err = runtime.BindQueryParameter("form", true, false, "reviewStatus", ctx.QueryParams(), &params.ReviewStatus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter reviewStatus: %s", err))
	}

	// ------------- Optional query parameter "scopeStatus" -------------

	err = runtime.BindQueryParameter("form", true, false, "scopeStatus", ctx.QueryParams(), &params.ScopeStatus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scopeStatus: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListOssVersions(ctx, ossId, params)
	return err
}

// CreateOssVersion converts echo context to params.
func (w *ServerInterfaceWrapper) CreateOssVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ossId" -------------
	var ossId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "ossId", ctx.Param("ossId"), &ossId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ossId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateOssVersion(ctx, ossId)
	return err
}

// DeleteOssVersion converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteOssVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ossId" -------------
	var ossId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "ossId", ctx.Param("ossId"), &ossId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ossId: %s", err))
	}

	// ------------- Path parameter "versionId" -------------
	var versionId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "versionId", ctx.Param("versionId"), &versionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter versionId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteOssVersion(ctx, ossId, versionId)
	return err
}

// GetOssVersion converts echo context to params.
func (w *ServerInterfaceWrapper) GetOssVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ossId" -------------
	var ossId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "ossId", ctx.Param("ossId"), &ossId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ossId: %s", err))
	}

	// ------------- Path parameter "versionId" -------------
	var versionId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "versionId", ctx.Param("versionId"), &versionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter versionId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetOssVersion(ctx, ossId, versionId)
	return err
}

// UpdateOssVersion converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateOssVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ossId" -------------
	var ossId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "ossId", ctx.Param("ossId"), &ossId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ossId: %s", err))
	}

	// ------------- Path parameter "versionId" -------------
	var versionId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "versionId", ctx.Param("versionId"), &versionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter versionId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateOssVersion(ctx, ossId, versionId)
	return err
}

// ListProjects converts echo context to params.
func (w *ServerInterfaceWrapper) ListProjects(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListProjectsParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", ctx.QueryParams(), &params.Size)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter size: %s", err))
	}

	// ------------- Optional query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, false, "code", ctx.QueryParams(), &params.Code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListProjects(ctx, params)
	return err
}

// CreateProject converts echo context to params.
func (w *ServerInterfaceWrapper) CreateProject(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateProject(ctx)
	return err
}

// DeleteProject converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteProject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteProject(ctx, projectId)
	return err
}

// GetProject converts echo context to params.
func (w *ServerInterfaceWrapper) GetProject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetProject(ctx, projectId)
	return err
}

// UpdateProject converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateProject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateProject(ctx, projectId)
	return err
}

// ExportProjectArtifacts converts echo context to params.
func (w *ServerInterfaceWrapper) ExportProjectArtifacts(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ExportProjectArtifactsParams
	// ------------- Required query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, true, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "scopes" -------------

	err = runtime.BindQueryParameter("form", true, false, "scopes", ctx.QueryParams(), &params.Scopes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scopes: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ExportProjectArtifacts(ctx, projectId, params)
	return err
}

// ListProjectUsages converts echo context to params.
func (w *ServerInterfaceWrapper) ListProjectUsages(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListProjectUsagesParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", ctx.QueryParams(), &params.Size)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter size: %s", err))
	}

	// ------------- Optional query parameter "scopeStatus" -------------

	err = runtime.BindQueryParameter("form", true, false, "scopeStatus", ctx.QueryParams(), &params.ScopeStatus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scopeStatus: %s", err))
	}

	// ------------- Optional query parameter "usageRole" -------------

	err = runtime.BindQueryParameter("form", true, false, "usageRole", ctx.QueryParams(), &params.UsageRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter usageRole: %s", err))
	}

	// ------------- Optional query parameter "direct" -------------

	err = runtime.BindQueryParameter("form", true, false, "direct", ctx.QueryParams(), &params.Direct)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direct: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListProjectUsages(ctx, projectId, params)
	return err
}

// CreateProjectUsage converts echo context to params.
func (w *ServerInterfaceWrapper) CreateProjectUsage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateProjectUsage(ctx, projectId)
	return err
}

// DeleteProjectUsage converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteProjectUsage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	// ------------- Path parameter "usageId" -------------
	var usageId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "usageId", ctx.Param("usageId"), &usageId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter usageId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteProjectUsage(ctx, projectId, usageId)
	return err
}

// UpdateProjectUsage converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateProjectUsage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	// ------------- Path parameter "usageId" -------------
	var usageId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "usageId", ctx.Param("usageId"), &usageId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter usageId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateProjectUsage(ctx, projectId, usageId)
	return err
}

// UpdateProjectUsageScope converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateProjectUsageScope(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	// ------------- Path parameter "usageId" -------------
	var usageId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "usageId", ctx.Param("usageId"), &usageId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter usageId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateProjectUsageScope(ctx, projectId, usageId)
	return err
}

// GetScopePolicy converts echo context to params.
func (w *ServerInterfaceWrapper) GetScopePolicy(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScopePolicy(ctx)
	return err
}

// UpdateScopePolicy converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateScopePolicy(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateScopePolicy(ctx)
	return err
}

// ListTags converts echo context to params.
func (w *ServerInterfaceWrapper) ListTags(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListTags(ctx)
	return err
}

// CreateTag converts echo context to params.
func (w *ServerInterfaceWrapper) CreateTag(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateTag(ctx)
	return err
}

// DeleteTag converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteTag(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "tagId" -------------
	var tagId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "tagId", ctx.Param("tagId"), &tagId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tagId: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteTag(ctx, tagId)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/audit", wrapper.SearchAuditLogs)
	router.GET(baseURL+"/oss", wrapper.ListOssComponents)
	router.POST(baseURL+"/oss", wrapper.CreateOssComponent)
	router.DELETE(baseURL+"/oss/:ossId", wrapper.DeprecateOssComponent)
	router.GET(baseURL+"/oss/:ossId", wrapper.GetOssComponent)
	router.PATCH(baseURL+"/oss/:ossId", wrapper.UpdateOssComponent)
	router.GET(baseURL+"/oss/:ossId/versions", wrapper.ListOssVersions)
	router.POST(baseURL+"/oss/:ossId/versions", wrapper.CreateOssVersion)
	router.DELETE(baseURL+"/oss/:ossId/versions/:versionId", wrapper.DeleteOssVersion)
	router.GET(baseURL+"/oss/:ossId/versions/:versionId", wrapper.GetOssVersion)
	router.PATCH(baseURL+"/oss/:ossId/versions/:versionId", wrapper.UpdateOssVersion)
	router.GET(baseURL+"/projects", wrapper.ListProjects)
	router.POST(baseURL+"/projects", wrapper.CreateProject)
	router.DELETE(baseURL+"/projects/:projectId", wrapper.DeleteProject)
	router.GET(baseURL+"/projects/:projectId", wrapper.GetProject)
	router.PATCH(baseURL+"/projects/:projectId", wrapper.UpdateProject)
	router.GET(baseURL+"/projects/:projectId/export", wrapper.ExportProjectArtifacts)
	router.GET(baseURL+"/projects/:projectId/usages", wrapper.ListProjectUsages)
	router.POST(baseURL+"/projects/:projectId/usages", wrapper.CreateProjectUsage)
	router.DELETE(baseURL+"/projects/:projectId/usages/:usageId", wrapper.DeleteProjectUsage)
	router.PATCH(baseURL+"/projects/:projectId/usages/:usageId", wrapper.UpdateProjectUsage)
	router.PATCH(baseURL+"/projects/:projectId/usages/:usageId/scope", wrapper.UpdateProjectUsageScope)
	router.GET(baseURL+"/scope/policy", wrapper.GetScopePolicy)
	router.PATCH(baseURL+"/scope/policy", wrapper.UpdateScopePolicy)
	router.GET(baseURL+"/tags", wrapper.ListTags)
	router.POST(baseURL+"/tags", wrapper.CreateTag)
	router.DELETE(baseURL+"/tags/:tagId", wrapper.DeleteTag)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
